use crate::compiler::bali::bali_ast::{BaliProgram, BaliContext, TopLevelEffect, Statement, Effect, Expression, Value, Fraction, ConcreteFraction, BooleanExpression, set_context_effect_set};

grammar;

pub Program: BaliProgram = {
    <s: StatementSet?> => s.unwrap_or(Vec::new()),
};

startWith = "(with";
endWith = ")";


pub OptionalWithContext: BaliContext = {
    <c: WithContext?> => {
        match c {
            Some(c) => c,
            None => BaliContext::new(),
        }
    }
}

pub WithContext: BaliContext = {
    <mut c: WithContext> <ce: ContextElement> => ce.update(c),
    <ce: ContextElement> => ce,
}

pub ContextElement: BaliContext = {
    "dev:" <e: Expression> => {let mut c = BaliContext::new(); c.device = Some(*e); c},
    "ch:" <e: Expression> => {let mut c = BaliContext::new(); c.channel = Some(*e); c},
    "v:" <e: Expression> => {let mut c = BaliContext::new(); c.velocity = Some(*e); c},
    "dur:" <f: AbstractFraction> => {let mut c = BaliContext::new(); c.duration = Some(f); c}
}

pub StatementSet: Vec<Statement> = {
    <mut s: StatementSet> <t: Statement> => { s.push(t); s },
    <s: StatementSet> Comment => s,
    <t: Statement> => vec![t],
    Comment => Vec::new(),
}

pub Statement: Statement = {
    "(?" <num_choices: Number?> <c: OptionalWithContext> <s: StatementSet> ")" => {
        let num_choices = num_choices.unwrap_or(1);
        Statement::Choice(num_choices, s.len() as i64, s, c)
    },
    "(>" <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::AfterFrac(n, s, c),
    "(<" <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::BeforeFrac(n, s, c),
    "(loop" <it: Number> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Loop(it, n, s, c),
    "(eucloop" <beats: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Euclidean(beats, steps, shift, false, false, n, s, c),
    "(binloop" <it: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Binary(it, steps, shift, false, false, n, s, c),
    "(eucrloop" <beats: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Euclidean(beats, steps, shift, true, false, n, s, c),
    "(binrloop" <it: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Binary(it, steps, shift, true, false, n, s, c),
    "(neucloop" <beats: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Euclidean(beats, steps, shift, false, true, n, s, c),
    "(nbinloop" <it: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Binary(it, steps, shift, false, true, n, s, c),
    "(neucrloop" <beats: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Euclidean(beats, steps, shift, true, true, n, s, c),
    "(nbinrloop" <it: Number> <steps: Number> <shift: Number?> <n: ConcreteFraction> <c: OptionalWithContext> <s: StatementSet> ")" => Statement::Binary(it, steps, shift, true, true, n, s, c),
    "(>>" <c: OptionalWithContext> <s: TopLevelEffectSet> ")" => Statement::After(s, c),
    "(<<" <c: OptionalWithContext> <s: TopLevelEffectSet> ")" => Statement::Before(s, c),
    startWith <c: WithContext> <s: StatementSet> endWith => Statement::With(s, c),
    <e: TopLevelEffect> => Statement::Effect(e, BaliContext::new()),
};

pub TopLevelEffect: TopLevelEffect = {
    "(seq" <c: OptionalWithContext> <es: TopLevelEffectSet> ")" => TopLevelEffect::Seq(es, c),
    "(for" <cond: BooleanExpression> <c: OptionalWithContext> <es: TopLevelEffectSet> ")" => TopLevelEffect::For(cond, es, c),
    "(if" <cond: BooleanExpression> <c: OptionalWithContext> <th: TopLevelEffectSet>")" => TopLevelEffect::If(cond, th, c),
    <e: Effect> => TopLevelEffect::Effect(e, BaliContext::new()),
}

pub TopLevelEffectSet: Vec<TopLevelEffect> = {
    startWith <c: WithContext> <es: TopLevelEffectSet> endWith => set_context_effect_set(es, c),
    <mut es: TopLevelEffectSet> <e: TopLevelEffect> => { es.push(e); es },
    <e: TopLevelEffect> => vec![e],
};

pub Effect: Effect = {
    "(def" <v: Name> <ex: Expression> ")" => Effect::Definition(v, ex),
    "(note" <n: Expression> <c: OptionalWithContext> ")" => Effect::Note(n, c),
    "(prog" <v: Expression> <c: OptionalWithContext> ")" => Effect::ProgramChange(v, c),
    "(control" <v1: Expression> <v2: Expression> <c: OptionalWithContext> ")" => Effect::ControlChange(v1, v2, c),
    "(osc" <addr: StringLiteral> <args: Expression*> <c: OptionalWithContext> ")" => Effect::Osc(addr.trim_matches('"').to_string(), args.into_iter().map(|e| *e).collect(), c),
    "(dirt" <sound: Expression> <params: DirtParam*> <c: OptionalWithContext> ")" => Effect::Dirt(sound, params, c),
};

pub BooleanExpression: Box<BooleanExpression> = {
    "(and" <e1: BooleanExpression> <e2: BooleanExpression> ")" => Box::new(BooleanExpression::And(e1, e2)),
    "(or" <e1: BooleanExpression> <e2: BooleanExpression> ")" => Box::new(BooleanExpression::Or(e1, e2)),
    "(not" <e: BooleanExpression> ")" => Box::new(BooleanExpression::Not(e)),
    "(lt" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Lower(e1, e2)),
    "(leq" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::LowerOrEqual(e1, e2)),
    "(gt" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Greater(e1, e2)),
    "(geq" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::GreaterOrEqual(e1, e2)),
    "(==" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Equal(e1, e2)),
    "(!=" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Different(e1, e2)),
}

pub Expression: Box<Expression> = {
    "(+" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Addition(v1, v2)),
    "(*" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Multiplication(v1, v2)),
    "(-" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Subtraction(v1, v2)),
    "(/" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Division(v1, v2)),
    "(%" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Modulo(v1, v2)),
    "(scale" <val: Expression> <old_min: Expression> <old_max: Expression> <new_min: Expression> <new_max: Expression> ")" => 
        Box::new(Expression::Scale(val, old_min, old_max, new_min, new_max)),
    "(clamp" <val: Expression> <min: Expression> <max: Expression> ")" => Box::new(Expression::Clamp(val, min, max)),
    "(min" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Min(v1, v2)),
    "(max" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Max(v1, v2)),
    "(quantize" <val: Expression> <step: Expression> ")" => Box::new(Expression::Quantize(val, step)),
    "(sine" <speed: Expression> ")" => Box::new(Expression::Sine(speed)),
    "(saw" <speed: Expression> ")" => Box::new(Expression::Saw(speed)),
    "(triangle" <speed: Expression> ")" => Box::new(Expression::Triangle(speed)),
    "(isaw" <speed: Expression> ")" => Box::new(Expression::ISaw(speed)),
    "(randstep" <speed: Expression> ")" => Box::new(Expression::RandStep(speed)),
    "(ccin" <ctrl: Expression> <ctx: OptionalCcinContext> ")" => {
        let (dev_opt, chan_opt) = ctx;
        Box::new(Expression::MidiCC(ctrl, dev_opt, chan_opt))
    },
    <v: Value> => Box::new(Expression::Value(v)),
};

pub Value: Value = {
    <n: Number> => Value::Number(n),
    <v: Name> => v,
    <s: StringLiteral> => Value::String(s.trim_matches('"').to_string()),
};

#[inline]
AbstractFraction: Fraction = {
    "(//" <numerator: Expression> <denominator: Expression> ")" => Fraction{numerator, denominator},
    "(" <numerator: Expression> "//" <denominator: Expression> ")" => Fraction{numerator, denominator},
    <numerator: Expression> => Fraction{numerator, denominator: Box::new(Expression::Value(Value::Number(1)))},
    <d: Dec> => Fraction::from_dec_string(d),
};

ConcreteFraction: ConcreteFraction = {
    "(//" <numerator: Number> <denominator: Number> ")" => ConcreteFraction{signe: 1, numerator, denominator},
    "(" <numerator: Number> "//" <denominator: Number> ")" => ConcreteFraction{signe: 1, numerator, denominator},
    <numerator: Number> => ConcreteFraction{signe: 1, numerator, denominator: 1},
    <d: Dec> => ConcreteFraction::from_dec_string(d),
};

Dec: String = <s:r"[0-9]*\.[0-9]+"> => s.to_string();

Number: i64 = <s:r"[0-9]+"> => { 
    if let Ok(v) = s.parse::<u64>() {
        (v % 128) as i64
    } else {
        0
    }
};

Name: Value = <s:r"[a-zA-Z][-a-zA-Z0-9#]*"> => Value::Variable(s.to_string());

Comment = r";.*";

StringLiteral: String = <s:r#""([^"\\]|\\.)*""#> => s.to_string();

// Rule for parsing Dirt parameters: :keyword Expression
DirtParam: (String, Box<Expression>) = {
    <key: Keyword> <val: Expression> => (key.trim_start_matches(':').to_string(), val),
};

// Add Keyword terminal (starts with :, followed by identifier characters)
Keyword: String = <s:r":[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string();

// Define elements allowed inside ccin context specifier
// Returns (dev_expr_option, chan_expr_option) tuple
CcinContextElement: (Option<Box<Expression>>, Option<Box<Expression>>) = {
    "dev:" <e: Expression> => (Some(e), None),
    "ch:" <e: Expression> => (None, Some(e)),
};

// Define the optional context for ccin, accumulating dev/chan options
// Takes the last specified value for dev/chan if duplicated.
// Returns (final_dev_option, final_chan_option)
OptionalCcinContext: (Option<Box<Expression>>, Option<Box<Expression>>) = {
    // Base case: no context elements provided
    => (None, None),

    // Recursive case: process one element and merge with the rest of the context
    // The grammar will parse elements left-to-right. We update the tuple `ctx`
    // as we go, overwriting previous dev/chan if encountered again.
    <mut ctx: OptionalCcinContext> <elem: CcinContextElement> => {
        let (elem_dev, elem_chan) = elem;
        if elem_dev.is_some() {
            ctx.0 = elem_dev; // Update device if this element has one
        }
        if elem_chan.is_some() {
            ctx.1 = elem_chan; // Update channel if this element has one
        }
        ctx // Return the updated context tuple
    }
};