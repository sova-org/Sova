use crate::compiler::bali::bali_ast::{BaliProgram, TopLevelStatement, Statement, Effect, Expression, Value, Fraction, ConcreteFraction};

grammar;


FractionBegin = "(//";
FractionEnd = ")";
SetBegin = "[";
SetEnd = "]";

pub Program: BaliProgram = {
    <mut p: Program> <t: TopLevelStatement> => { p.push(t); p },
    <t: TopLevelStatement> => vec![t],
};

pub TopLevelStatement: TopLevelStatement = {
    "(@" <n: ConcreteFraction> <s: StatementSet> ")" => TopLevelStatement::AtStatement(n, s),
    <s: StatementSet> => TopLevelStatement::Statement(s),
};

pub StatementSet: Vec<Statement> = {
    SetBegin <ss: StatementSetContent> SetEnd => ss,
    <s: Statement> => vec![s],
}

pub StatementSetContent: Vec<Statement> = {
    <mut ss: StatementSet> <s: Statement> => { ss.push(s); ss },
    <s: Statement> => vec![s],
};

pub Statement: Statement = {
    "(>" <n: ConcreteFraction> <es: EffectSet> ")" => Statement::AfterFrac(n, es),
    "(>>" <es: EffectSet> ")" => Statement::After(es),
    "(<" <n: ConcreteFraction> <es: EffectSet> ")" => Statement::BeforeFrac(n, es),
    "(<<" <es: EffectSet> ")" => Statement::Before(es),
    "(l" <it: Number> <n: ConcreteFraction> <before: EffectSet> <es: EffectSet> <after: EffectSet> ")" => Statement::Loop(it, n, Some(before), es, Some(after)),
    "(l" <it: Number> <n: ConcreteFraction> <before: EffectSet> <es: EffectSet> ")" => Statement::Loop(it, n, Some(before), es, None),
    "(l" <it: Number> <n: ConcreteFraction> <before: EffectSet> <es: EffectSet> SetBegin SetEnd ")" => Statement::Loop(it, n, Some(before), es, None),
    "(l" <it: Number> <n: ConcreteFraction> SetBegin SetEnd <es: EffectSet> <after: EffectSet> ")" => Statement::Loop(it, n, None, es, Some(after)),
    "(l" <it: Number> <n: ConcreteFraction> <ef: EffectSet> ")" => Statement::Loop(it, n, None, ef, None),
    <e: Effect> => Statement::Effect(vec![e]),
};

pub EffectSet: Vec<Effect> = {
    SetBegin <es: EffectSetContent> SetEnd => es,
    <e: Effect> => vec![e], 
};

pub EffectSetContent: Vec<Effect> = {
    <mut es: EffectSet> <e: Effect> => { es.push(e); es },
    <e: Effect> => vec![e],
};

pub Effect: Effect = {
    "(d" <v: Name> <ex: Expression> ")" => Effect::Definition(v, ex),
    "(n" <vn: Expression> <vv: Expression> <vc: Expression> <vd: AbstractFraction> ")" => Effect::Note(vn, Some(vv), Some(vc), vd),
    "(n" <vn: Expression> <vv: Expression> <vd: AbstractFraction> ")" => Effect::Note(vn, Some(vv), None, vd),
    "(n" <vn: Expression> <vd: AbstractFraction> ")" => Effect::Note(vn, None, None, vd),
    "(pc" <v1: Expression> <v2: Expression> ")" => Effect::ProgramChange(v1, v2),
    "(cc" <v1: Expression> <v2: Expression> <v3: Expression> ")" => Effect::ControlChange(v1, v2, v3),
};

pub AbstractFraction: Fraction = {
    FractionBegin <numerator: Expression> <denominator: Expression> FractionEnd => Fraction{numerator, denominator},
    <denominator: Expression> => Fraction{numerator: Box::new(Expression::Value(Value::Number(1))), denominator},
};

pub Expression: Box<Expression> = {
    "(+" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Addition(v1, v2)),
    "(*" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Multiplication(v1, v2)),
    "(-" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Subtraction(v1, v2)),
    "(/" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Division(v1, v2)),
    "(%" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Modulo(v1, v2)),
    <v: Value> => Box::new(Expression::Value(v)),
};

pub Value: Value = {
    <n: Number> => Value::Number(n),
    <v: Name> => v,
};


ConcreteFraction: ConcreteFraction = {
    FractionBegin <numerator: Number> <denominator: Number> FractionEnd => ConcreteFraction{numerator, denominator},
    <denominator: Number> => ConcreteFraction{numerator: 1, denominator},
};

Number: u8 = <s:r"[0-9]+"> => { 
    if let Ok(v) = s.parse::<u64>() {
        (v % 128) as u8
    } else {
        0
    }
};

Name: Value = <s:r"[a-zA-Z][-a-zA-Z0-9#]*"> => Value::Variable(s.to_string());