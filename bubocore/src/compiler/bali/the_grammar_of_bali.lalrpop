use crate::compiler::bali::bali_ast::{BaliProgram, BaliContext, TopLevelEffect, Statement, Effect, Expression, Value, Fraction, ConcreteFraction, BooleanExpression, set_context_prog, set_context_effect_set};

grammar;

pub Program: BaliProgram = {
    <s: StatementSet> => s,
};

startWith = "(with";
endWith = ")";

pub WithContext: BaliContext = {
    <mut c: WithContext> "ch:" <n: Number> => { c.channel = Some(n); c },
    <mut c: WithContext> "dev:" <n: Number> => { c.device = Some(n); c },
    <mut c: WithContext> "v:" <n: Number> => { c.velocity = Some(n); c },
    "dev:" <n: Number> => {let mut c = BaliContext::new(); c.device = Some(n); c},
    "ch:" <n: Number> => {let mut c = BaliContext::new(); c.channel = Some(n); c},
    "v:" <n: Number> => {let mut c = BaliContext::new(); c.velocity = Some(n); c},
}

pub StatementSet: Vec<Statement> = {
    <mut s: StatementSet> <t: Statement> => { s.push(t); s },
    <mut s: StatementSet> startWith <c: WithContext> <ss: StatementSet> endWith => { s.extend(set_context_prog(ss, c)); s },
    startWith <c: WithContext> <s: StatementSet> endWith => set_context_prog(s, c),
    <s: StatementSet> Comment => s,
    <t: Statement> => vec![t],
    Comment => Vec::new(),
}

pub Statement: Statement = {
    "(>" <n: ConcreteFraction> <s: StatementSet> ")" => Statement::AfterFrac(n, s, BaliContext::new()),
    "(<" <n: ConcreteFraction> <s: StatementSet> ")" => Statement::BeforeFrac(n, s, BaliContext::new()),
    "(loop" <it: Number> <n: ConcreteFraction> <s: StatementSet> ")" => Statement::Loop(it, n, s, BaliContext::new()),
    "(>>" <s: TopLevelEffectSet> ")" => Statement::After(s, BaliContext::new()),
    "(<<" <s: TopLevelEffectSet> ")" => Statement::Before(s, BaliContext::new()),
    <e: TopLevelEffect> => Statement::Effect(e, BaliContext::new()),
};

pub TopLevelEffect: TopLevelEffect = {
    "(seq" <es: TopLevelEffectSet> ")" => TopLevelEffect::Seq(es, BaliContext::new()),
    "(for" <cond: BooleanExpression> <es: TopLevelEffectSet> ")" => TopLevelEffect::For(cond, es, BaliContext::new()),
    "(if" <cond: BooleanExpression> <th: TopLevelEffectSet>")" => TopLevelEffect::If(cond, th, BaliContext::new()),
    <e: Effect> => TopLevelEffect::Effect(e, BaliContext::new()),
}

pub TopLevelEffectSet: Vec<TopLevelEffect> = {
    <mut es: TopLevelEffectSet> <e: TopLevelEffect> => { es.push(e); es },
    <mut es: TopLevelEffectSet> startWith <c: WithContext> <ess: TopLevelEffectSet> endWith => { es.extend(set_context_effect_set(ess, c)); es },
    startWith <c: WithContext> <es: TopLevelEffectSet> endWith => set_context_effect_set(es, c),
    <e: TopLevelEffect> => vec![e],
};

pub Effect: Effect = {
    "(def" <v: Name> <ex: Expression> ")" => Effect::Definition(v, ex),
    "(note" <vn: Expression> <vv: Expression> <vc: Expression> <vd: AbstractFraction> ")" => Effect::Note(vn, Some(vv), Some(vc), vd),
    "(note" <vn: Expression> <vv: Expression> <vd: AbstractFraction> ")" => Effect::Note(vn, Some(vv), None, vd),
    "(note" <vn: Expression> <vd: AbstractFraction> ")" => Effect::Note(vn, None, None, vd),
    "(prog" <v1: Expression> <v2: Expression> ")" => Effect::ProgramChange(v1, v2),
    "(control" <v1: Expression> <v2: Expression> <v3: Expression> ")" => Effect::ControlChange(v1, v2, v3),
};

pub BooleanExpression: Box<BooleanExpression> = {
    "(and" <e1: BooleanExpression> <e2: BooleanExpression> ")" => Box::new(BooleanExpression::And(e1, e2)),
    "(or" <e1: BooleanExpression> <e2: BooleanExpression> ")" => Box::new(BooleanExpression::Or(e1, e2)),
    "(not" <e: BooleanExpression> ")" => Box::new(BooleanExpression::Not(e)),
    "(lt" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Lower(e1, e2)),
    "(leq" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::LowerOrEqual(e1, e2)),
    "(gt" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Greater(e1, e2)),
    "(geq" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::GreaterOrEqual(e1, e2)),
    "(==" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Equal(e1, e2)),
    "(!=" <e1: Expression> <e2: Expression> ")" => Box::new(BooleanExpression::Different(e1, e2)),
}

pub Expression: Box<Expression> = {
    "(+" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Addition(v1, v2)),
    "(*" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Multiplication(v1, v2)),
    "(-" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Subtraction(v1, v2)),
    "(/" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Division(v1, v2)),
    "(%" <v1: Expression> <v2: Expression> ")" => Box::new(Expression::Modulo(v1, v2)),
    <v: Value> => Box::new(Expression::Value(v)),
};

pub Value: Value = {
    <n: Number> => Value::Number(n),
    <v: Name> => v,
};

pub AbstractFraction: Fraction = {
    "(//" <numerator: Expression> <denominator: Expression> ")" => Fraction{numerator, denominator},
    "(" <numerator: Expression> "//" <denominator: Expression> ")" => Fraction{numerator, denominator},
    <denominator: Expression> => Fraction{numerator: Box::new(Expression::Value(Value::Number(1))), denominator},
};

ConcreteFraction: ConcreteFraction = {
    "(//" <numerator: Number> <denominator: Number> ")" => ConcreteFraction{signe: 1, numerator, denominator},
    "(" <numerator: Number> "//" <denominator: Number> ")" => ConcreteFraction{signe: 1, numerator, denominator},
    <denominator: Number> => {
        if denominator == 0 {
            ConcreteFraction{signe: 1, numerator: 0, denominator: 1}
        } else {
            ConcreteFraction{signe: 1, numerator: 1, denominator}
        }
    },
};

Number: i64 = <s:r"[0-9]+"> => { 
    if let Ok(v) = s.parse::<u64>() {
        (v % 128) as i64
    } else {
        0
    }
};

Name: Value = <s:r"[a-zA-Z][-a-zA-Z0-9#]*"> => Value::Variable(s.to_string());

Comment = r";.*";