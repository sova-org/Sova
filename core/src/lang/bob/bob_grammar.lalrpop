use crate::lang::bob::bob_ast::{BobProgram, BobValue, BobExpr};

grammar;

match {
    r"\s*" => {},              // skip whitespace

    // Note literals (must come before comment rule since # is used for sharps)
    r":[a-gA-G][#b]?-?[0-9]*[#b]?" => NOTE,

    r"#[^\n\r]*" => {},        // skip comments (# to end of line)

    // Control keywords
    "PLAY", ">>", "@", "WAIT", "DEV", "IF", "ELSE", "WHILE", "RANGE", "EACH", "DO", "EVERY", "PROB", "BREAK", "SWITCH", "CASE", "DEFAULT", "CHOOSE", "ALT", "BYTES", "END", "SET", "FORK", "EU", "BIN",
    // Special single-letter vars (must be before UPPER regex)
    "T", "R", "I", "E",
    // Function keywords
    "FUNC", "CALL", "FN",
    // Map keywords
    "MNEW", "MGET", "MSET", "MHAS", "MMERGE", "MLEN",
    // List functional operations
    "MAP", "FILTER", "REDUCE",
    // Ternary conditional
    "?",
    // Sequence
    ";",

    // Punctuation
    ":", "(", ")", "[", "]", "'[", "{", "}",
    "G.", "F.", "L.",

    // Symbolic math operators
    "+", "-", "*", "/", "%",
    ">", "<", ">=", "<=", "==", "!=",
    "&&", "||", "!",
    "&", "|", "^", "<<", "~",

    // Numbers
    r"-?[0-9]+\.[0-9]+" => FLOAT,
    r"-?[0-9]+" => INT,

    // Strings
    r#""([^"\\]|\\.)*""# => STRING,

    // Single uppercase letter (for globals A-Z and env T, R)
    r"[A-Z]" => UPPER,

    // Unary operators (1 arg)
    "NEG", "NOT", "BNOT", "ABS", "TOSS", "LEN", "PICK", "CYCLE",

    // Binary operators (2 args)
    "ADD", "SUB", "MUL", "DIV", "MOD",
    "GT", "LT", "GTE", "LTE", "EQ", "NE",
    "AND", "OR", "XOR",
    "BAND", "BOR", "BXOR", "SHL", "SHR",
    "MIN", "MAX", "QT", "RAND", "RRAND", "DRUNK", "GET",

    // Ternary operators (3 args)
    "CLAMP", "WRAP",

    // Quinary operators (5 args)
    "SCALE",

    // Function names (uppercase words, 2+ chars) - fallback for unknown ops
    r"[A-Z][A-Z0-9]+" => FUNC,

    // Lowercase identifier (for instance vars and keys)
    r"[a-z][a-z0-9_]*" => LOWER,
}

// Program is a sequence expression (or empty)
pub Program: BobProgram = {
    <e:SeqExpr> => e,
    => BobExpr::Unit,
};

// Sequence: expr; expr; expr - right associative, returns last value
SeqExpr: BobExpr = {
    <left:Expr> ";" <right:SeqExpr> => BobExpr::Seq(Box::new(left), Box::new(right)),
    <e:Expr> => e,
};

#[inline]
PlayKw: () = { "PLAY" => (), ">>" => (), "@" => () };

// Map literal key-value pair with colon separator
MapPair: (String, Box<BobExpr>) = {
    <key:LOWER> ":" <val:Expr> => (key.to_string(), Box::new(val)),
};

// Case clause for switch: CASE val : expr (colon style)
CaseClause: (BobExpr, BobExpr) = {
    "CASE" <val:Expr> ":" <result:SeqExpr> => (val, result),
};

// Case clause for switch: CASE val { expr } (brace style)
BraceCaseClause: (BobExpr, BobExpr) = {
    "CASE" <val:Expr> "{" <result:SeqExpr> "}" => (val, result),
};



// All expressions - no ambiguity, assignment requires SET keyword
Expr: BobExpr = {
    <e:AtomExpr> => e,
};

// Atomic expressions
AtomExpr: BobExpr = {
    <v:Value> => BobExpr::Value(v),

    // Assignment: SET G.X expr - assigns AND returns value
    "SET" <dest:AssignableVar> <val:Expr> => BobExpr::Assign(dest, Box::new(val)),

    // Emit: => expr or PLAY expr
    PlayKw <e:Expr> => BobExpr::Emit(Box::new(e)),

    // List literal: '[1 2 3]
    "'[" <elems:Expr*> "]" => BobExpr::List(elems),

    // Map literal: [key: val]
    "[" <pairs:MapPair*> "]" => BobExpr::MapLiteral(pairs),

    // CHOOSE: randomly select one
    "CHOOSE" ":" <options:Expr+> "END" => BobExpr::Choose(options),
    "CHOOSE" "{" <options:Expr+> "}" => BobExpr::Choose(options),

    // ALT: cycle through sequentially
    "ALT" ":" <options:Expr+> "END" => BobExpr::Alt(options),
    "ALT" "{" <options:Expr+> "}" => BobExpr::Alt(options),

    // FORK: spawn a concurrent execution branch
    "FORK" ":" <body:SeqExpr> "END" => BobExpr::Fork { body: Box::new(body) },
    "FORK" "{" <body:SeqExpr> "}" => BobExpr::Fork { body: Box::new(body) },

    // BYTES: byte array
    "BYTES" ":" <bytes:Expr+> "END" => BobExpr::Bytes(bytes),
    "BYTES" "{" <bytes:Expr+> "}" => BobExpr::Bytes(bytes),

    // IF expression (colon style)
    "IF" <cond:Expr> ":" <then_e:SeqExpr> "ELSE" ":" <else_e:SeqExpr> "END" =>
        BobExpr::If {
            condition: Box::new(cond),
            then_expr: Box::new(then_e),
            else_expr: Box::new(else_e),
        },
    "IF" <cond:Expr> ":" <then_e:SeqExpr> "END" =>
        BobExpr::If {
            condition: Box::new(cond),
            then_expr: Box::new(then_e),
            else_expr: Box::new(BobExpr::Value(BobValue::Int(0))),
        },
    // IF expression (brace style) - ELSE is required to avoid dangling-else ambiguity
    "IF" <cond:Expr> "{" <then_e:SeqExpr> "}" "ELSE" "{" <else_e:SeqExpr> "}" =>
        BobExpr::If {
            condition: Box::new(cond),
            then_expr: Box::new(then_e),
            else_expr: Box::new(else_e),
        },

    // SWITCH expression (colon style)
    "SWITCH" <val:Expr> ":" <cases:CaseClause+> "DEFAULT" ":" <default:SeqExpr> "END" =>
        BobExpr::Switch {
            value: Box::new(val),
            cases,
            default: Box::new(default),
        },
    "SWITCH" <val:Expr> ":" <cases:CaseClause+> "END" =>
        BobExpr::Switch {
            value: Box::new(val),
            cases,
            default: Box::new(BobExpr::Value(BobValue::Int(0))),
        },
    // SWITCH expression (brace style)
    "SWITCH" <val:Expr> "{" <cases:BraceCaseClause+> "DEFAULT" "{" <default:SeqExpr> "}" "}" =>
        BobExpr::Switch {
            value: Box::new(val),
            cases,
            default: Box::new(default),
        },
    "SWITCH" <val:Expr> "{" <cases:BraceCaseClause+> "}" =>
        BobExpr::Switch {
            value: Box::new(val),
            cases,
            default: Box::new(BobExpr::Value(BobValue::Int(0))),
        },

    // PROB expression (colon style)
    "PROB" <n:Expr> ":" <then_e:SeqExpr> "ELSE" ":" <else_e:SeqExpr> "END" =>
        BobExpr::Prob {
            threshold: Box::new(n),
            then_expr: Box::new(then_e),
            else_expr: Box::new(else_e),
        },
    "PROB" <n:Expr> ":" <then_e:SeqExpr> "END" =>
        BobExpr::Prob {
            threshold: Box::new(n),
            then_expr: Box::new(then_e),
            else_expr: Box::new(BobExpr::Value(BobValue::Int(0))),
        },
    // PROB expression (brace style) - ELSE is required to avoid dangling-else ambiguity
    "PROB" <n:Expr> "{" <then_e:SeqExpr> "}" "ELSE" "{" <else_e:SeqExpr> "}" =>
        BobExpr::Prob {
            threshold: Box::new(n),
            then_expr: Box::new(then_e),
            else_expr: Box::new(else_e),
        },

    // Loop expression (colon style)
    "RANGE" <start:Expr> <end:Expr> ":" <body:SeqExpr> "END" =>
        BobExpr::Loop {
            start: Box::new(start),
            end: Box::new(end),
            step: Box::new(BobExpr::Value(BobValue::Int(1))),
            body: Box::new(body),
        },
    "RANGE" <start:Expr> <end:Expr> <step:Expr> ":" <body:SeqExpr> "END" =>
        BobExpr::Loop {
            start: Box::new(start),
            end: Box::new(end),
            step: Box::new(step),
            body: Box::new(body),
        },
    // Loop expression (brace style)
    "RANGE" <start:Expr> <end:Expr> "{" <body:SeqExpr> "}" =>
        BobExpr::Loop {
            start: Box::new(start),
            end: Box::new(end),
            step: Box::new(BobExpr::Value(BobValue::Int(1))),
            body: Box::new(body),
        },
    "RANGE" <start:Expr> <end:Expr> <step:Expr> "{" <body:SeqExpr> "}" =>
        BobExpr::Loop {
            start: Box::new(start),
            end: Box::new(end),
            step: Box::new(step),
            body: Box::new(body),
        },

    // WHILE expression (colon style)
    "WHILE" <cond:Expr> ":" <body:SeqExpr> "END" =>
        BobExpr::While {
            condition: Box::new(cond),
            body: Box::new(body),
        },
    // WHILE expression (brace style)
    "WHILE" <cond:Expr> "{" <body:SeqExpr> "}" =>
        BobExpr::While {
            condition: Box::new(cond),
            body: Box::new(body),
        },

    // DO expression (colon style)
    "DO" <n:Expr> ":" <body:SeqExpr> "END" =>
        BobExpr::Do {
            count: Box::new(n),
            body: Box::new(body),
        },
    // DO expression (brace style)
    "DO" <n:Expr> "{" <body:SeqExpr> "}" =>
        BobExpr::Do {
            count: Box::new(n),
            body: Box::new(body),
        },

    // EACH expression (colon style)
    "EACH" <list:Expr> ":" <body:SeqExpr> "END" =>
        BobExpr::ForEach {
            list: Box::new(list),
            body: Box::new(body),
        },
    // EACH expression (brace style)
    "EACH" <list:Expr> "{" <body:SeqExpr> "}" =>
        BobExpr::ForEach {
            list: Box::new(list),
            body: Box::new(body),
        },

    // EVERY expression (colon style)
    "EVERY" <n:Expr> ":" <body:SeqExpr> "END" =>
        BobExpr::Every {
            period: Box::new(n),
            body: Box::new(body),
        },
    // EVERY expression (brace style)
    "EVERY" <n:Expr> "{" <body:SeqExpr> "}" =>
        BobExpr::Every {
            period: Box::new(n),
            body: Box::new(body),
        },

    // EU (Euclidean rhythm) expression (colon style)
    "EU" <hits:Expr> <steps:Expr> <dur:Expr> ":" <hit_body:SeqExpr> "ELSE" ":" <miss_body:SeqExpr> "END" =>
        BobExpr::Euclidean {
            hits: Box::new(hits),
            steps: Box::new(steps),
            dur: Box::new(dur),
            hit_body: Box::new(hit_body),
            miss_body: Box::new(miss_body),
        },
    "EU" <hits:Expr> <steps:Expr> <dur:Expr> ":" <hit_body:SeqExpr> "END" =>
        BobExpr::Euclidean {
            hits: Box::new(hits),
            steps: Box::new(steps),
            dur: Box::new(dur),
            hit_body: Box::new(hit_body),
            miss_body: Box::new(BobExpr::Unit),
        },
    // EU (Euclidean rhythm) expression (brace style) - ELSE is required to avoid dangling-else ambiguity
    "EU" <hits:Expr> <steps:Expr> <dur:Expr> "{" <hit_body:SeqExpr> "}" "ELSE" "{" <miss_body:SeqExpr> "}" =>
        BobExpr::Euclidean {
            hits: Box::new(hits),
            steps: Box::new(steps),
            dur: Box::new(dur),
            hit_body: Box::new(hit_body),
            miss_body: Box::new(miss_body),
        },

    // BIN (Binary rhythm) expression (colon style)
    "BIN" <pattern:Expr> <dur:Expr> ":" <hit_body:SeqExpr> "ELSE" ":" <miss_body:SeqExpr> "END" =>
        BobExpr::Binary {
            pattern: Box::new(pattern),
            dur: Box::new(dur),
            hit_body: Box::new(hit_body),
            miss_body: Box::new(miss_body),
        },
    "BIN" <pattern:Expr> <dur:Expr> ":" <hit_body:SeqExpr> "END" =>
        BobExpr::Binary {
            pattern: Box::new(pattern),
            dur: Box::new(dur),
            hit_body: Box::new(hit_body),
            miss_body: Box::new(BobExpr::Unit),
        },
    // BIN (Binary rhythm) expression (brace style) - ELSE is required to avoid dangling-else ambiguity
    "BIN" <pattern:Expr> <dur:Expr> "{" <hit_body:SeqExpr> "}" "ELSE" "{" <miss_body:SeqExpr> "}" =>
        BobExpr::Binary {
            pattern: Box::new(pattern),
            dur: Box::new(dur),
            hit_body: Box::new(hit_body),
            miss_body: Box::new(miss_body),
        },

    // WAIT expression
    "WAIT" <dur:Expr> => BobExpr::Wait(Box::new(dur)),

    // DEV expression
    "DEV" <id:Expr> => BobExpr::Dev(Box::new(id)),

    // BREAK expression
    "BREAK" => BobExpr::Break,

    // FUNC definition (colon style)
    "FUNC" <name:FUNC> <args:UPPER*> ":" <body:SeqExpr> "END" =>
        BobExpr::FunctionDef {
            name: name.to_string(),
            args: args.iter().map(|s| s.to_string()).collect(),
            body: Box::new(body),
        },
    // FUNC definition (brace style)
    "FUNC" <name:FUNC> <args:UPPER*> "{" <body:SeqExpr> "}" =>
        BobExpr::FunctionDef {
            name: name.to_string(),
            args: args.iter().map(|s| s.to_string()).collect(),
            body: Box::new(body),
        },

    // Lambda (colon style)
    "FN" <args:UPPER*> ":" <body:SeqExpr> "END" =>
        BobExpr::Lambda {
            args: args.iter().map(|s| s.to_string()).collect(),
            body: Box::new(body),
        },
    // Lambda (brace style)
    "FN" <args:UPPER*> "{" <body:SeqExpr> "}" =>
        BobExpr::Lambda {
            args: args.iter().map(|s| s.to_string()).collect(),
            body: Box::new(body),
        },

    // Map operations
    "MNEW" => BobExpr::MapNew,
    "MGET" <map:Expr> <key:Expr> => BobExpr::MapGet(Box::new(map), Box::new(key)),
    "MHAS" <map:Expr> <key:Expr> => BobExpr::MapHas(Box::new(map), Box::new(key)),
    "MSET" <map:Expr> <key:Expr> <val:Expr> => BobExpr::MapSet(Box::new(map), Box::new(key), Box::new(val)),
    "MMERGE" <a:Expr> <b:Expr> => BobExpr::MapMerge(Box::new(a), Box::new(b)),
    "MLEN" <map:Expr> => BobExpr::MapLen(Box::new(map)),

    // List functional operations
    "MAP" <fn_expr:Expr> <list:Expr> => BobExpr::Map(Box::new(fn_expr), Box::new(list)),
    "FILTER" <fn_expr:Expr> <list:Expr> => BobExpr::Filter(Box::new(fn_expr), Box::new(list)),
    "REDUCE" <fn_expr:Expr> <init:Expr> <list:Expr> => BobExpr::Reduce(Box::new(fn_expr), Box::new(init), Box::new(list)),

    // Nullary operators
    "TOSS" => BobExpr::Call("TOSS".to_string(), vec![]),

    // Unary operators
    "NEG" <a:Expr> => BobExpr::Call("NEG".to_string(), vec![a]),
    "NOT" <a:Expr> => BobExpr::Call("NOT".to_string(), vec![a]),
    "!" <a:Expr> => BobExpr::Call("NOT".to_string(), vec![a]),
    "BNOT" <a:Expr> => BobExpr::Call("BNOT".to_string(), vec![a]),
    "~" <a:Expr> => BobExpr::Call("BNOT".to_string(), vec![a]),
    "ABS" <a:Expr> => BobExpr::Call("ABS".to_string(), vec![a]),
    "RAND" <a:Expr> => BobExpr::Call("RAND".to_string(), vec![a]),
    "LEN" <a:Expr> => BobExpr::Call("LEN".to_string(), vec![a]),
    "PICK" <a:Expr> => BobExpr::Call("PICK".to_string(), vec![a]),
    "CYCLE" <a:Expr> => BobExpr::Call("CYCLE".to_string(), vec![a]),

    // Binary operators - word and symbolic forms
    "ADD" <a:Expr> <b:Expr> => BobExpr::Call("ADD".to_string(), vec![a, b]),
    "+" <a:Expr> <b:Expr> => BobExpr::Call("ADD".to_string(), vec![a, b]),
    "SUB" <a:Expr> <b:Expr> => BobExpr::Call("SUB".to_string(), vec![a, b]),
    "-" <a:Expr> <b:Expr> => BobExpr::Call("SUB".to_string(), vec![a, b]),
    "MUL" <a:Expr> <b:Expr> => BobExpr::Call("MUL".to_string(), vec![a, b]),
    "*" <a:Expr> <b:Expr> => BobExpr::Call("MUL".to_string(), vec![a, b]),
    "DIV" <a:Expr> <b:Expr> => BobExpr::Call("DIV".to_string(), vec![a, b]),
    "/" <a:Expr> <b:Expr> => BobExpr::Call("DIV".to_string(), vec![a, b]),
    "MOD" <a:Expr> <b:Expr> => BobExpr::Call("MOD".to_string(), vec![a, b]),
    "%" <a:Expr> <b:Expr> => BobExpr::Call("MOD".to_string(), vec![a, b]),
    "GT" <a:Expr> <b:Expr> => BobExpr::Call("GT".to_string(), vec![a, b]),
    ">" <a:Expr> <b:Expr> => BobExpr::Call("GT".to_string(), vec![a, b]),
    "LT" <a:Expr> <b:Expr> => BobExpr::Call("LT".to_string(), vec![a, b]),
    "<" <a:Expr> <b:Expr> => BobExpr::Call("LT".to_string(), vec![a, b]),
    "GTE" <a:Expr> <b:Expr> => BobExpr::Call("GTE".to_string(), vec![a, b]),
    ">=" <a:Expr> <b:Expr> => BobExpr::Call("GTE".to_string(), vec![a, b]),
    "LTE" <a:Expr> <b:Expr> => BobExpr::Call("LTE".to_string(), vec![a, b]),
    "<=" <a:Expr> <b:Expr> => BobExpr::Call("LTE".to_string(), vec![a, b]),
    "EQ" <a:Expr> <b:Expr> => BobExpr::Call("EQ".to_string(), vec![a, b]),
    "==" <a:Expr> <b:Expr> => BobExpr::Call("EQ".to_string(), vec![a, b]),
    "NE" <a:Expr> <b:Expr> => BobExpr::Call("NE".to_string(), vec![a, b]),
    "!=" <a:Expr> <b:Expr> => BobExpr::Call("NE".to_string(), vec![a, b]),
    "AND" <a:Expr> <b:Expr> => BobExpr::Call("AND".to_string(), vec![a, b]),
    "&&" <a:Expr> <b:Expr> => BobExpr::Call("AND".to_string(), vec![a, b]),
    "OR" <a:Expr> <b:Expr> => BobExpr::Call("OR".to_string(), vec![a, b]),
    "||" <a:Expr> <b:Expr> => BobExpr::Call("OR".to_string(), vec![a, b]),
    "XOR" <a:Expr> <b:Expr> => BobExpr::Call("XOR".to_string(), vec![a, b]),
    "BAND" <a:Expr> <b:Expr> => BobExpr::Call("BAND".to_string(), vec![a, b]),
    "&" <a:Expr> <b:Expr> => BobExpr::Call("BAND".to_string(), vec![a, b]),
    "BOR" <a:Expr> <b:Expr> => BobExpr::Call("BOR".to_string(), vec![a, b]),
    "|" <a:Expr> <b:Expr> => BobExpr::Call("BOR".to_string(), vec![a, b]),
    "BXOR" <a:Expr> <b:Expr> => BobExpr::Call("BXOR".to_string(), vec![a, b]),
    "^" <a:Expr> <b:Expr> => BobExpr::Call("BXOR".to_string(), vec![a, b]),
    "SHL" <a:Expr> <b:Expr> => BobExpr::Call("SHL".to_string(), vec![a, b]),
    "<<" <a:Expr> <b:Expr> => BobExpr::Call("SHL".to_string(), vec![a, b]),
    "SHR" <a:Expr> <b:Expr> => BobExpr::Call("SHR".to_string(), vec![a, b]),
    "MIN" <a:Expr> <b:Expr> => BobExpr::Call("MIN".to_string(), vec![a, b]),
    "MAX" <a:Expr> <b:Expr> => BobExpr::Call("MAX".to_string(), vec![a, b]),
    "QT" <a:Expr> <b:Expr> => BobExpr::Call("QT".to_string(), vec![a, b]),
    "RRAND" <a:Expr> <b:Expr> => BobExpr::Call("RRAND".to_string(), vec![a, b]),
    "DRUNK" <a:Expr> <b:Expr> => BobExpr::Call("DRUNK".to_string(), vec![a, b]),
    "GET" <a:Expr> <b:Expr> => BobExpr::Call("GET".to_string(), vec![a, b]),

    // Ternary operators
    "CLAMP" <a:Expr> <b:Expr> <c:Expr> => BobExpr::Call("CLAMP".to_string(), vec![a, b, c]),
    "WRAP" <a:Expr> <b:Expr> <c:Expr> => BobExpr::Call("WRAP".to_string(), vec![a, b, c]),

    // Quinary operators
    "SCALE" <a:Expr> <b:Expr> <c:Expr> <d:Expr> <e:Expr> => BobExpr::Call("SCALE".to_string(), vec![a, b, c, d, e]),

    // Ternary conditional: ? cond then else
    "?" <cond:Expr> <then_val:Expr> <else_val:Expr> => BobExpr::Ternary(Box::new(cond), Box::new(then_val), Box::new(else_val)),

    // Function call: (CALL FUNCNAME args...)
    "(" "CALL" <name:FUNC> <args:Expr*> ")" => BobExpr::FunctionCall(name.to_string(), args),
    "(" "CALL" <name:UPPER> <args:Expr*> ")" => BobExpr::FunctionCall(name.to_string(), args),
    "(" "CALL" "G." <name:UPPER> <args:Expr*> ")" => BobExpr::FunctionCall(name.to_string(), args),
    "(" "CALL" "G." <name:LOWER> <args:Expr*> ")" => BobExpr::FunctionCall(name.to_string(), args),

    // Parenthesized expressions (fallback for variadic or grouping)
    "(" <func:FUNC> <args:Expr*> ")" => BobExpr::Call(func.to_string(), args),
};

Value: BobValue = {
    <n:FLOAT> => BobValue::Float(n.parse().unwrap_or(0.0)),
    <n:INT> => BobValue::Int(n.parse().unwrap_or(0)),
    <s:STRING> => BobValue::Str(s[1..s.len()-1].to_string()),
    <v:VarRef> => v,
};

// Assignable variables - can appear on left side of assignment
AssignableVar: BobValue = {
    "G." <name:LOWER> => BobValue::GlobalVar(name.to_string()),
    "G." <s:UPPER> => BobValue::GlobalVar(s.to_string()),
    "G." <s:FUNC> => BobValue::GlobalVar(s.to_string()),
    "G." "T" => BobValue::GlobalVar("T".to_string()),
    "G." "R" => BobValue::GlobalVar("R".to_string()),
    "G." "I" => BobValue::GlobalVar("I".to_string()),
    "G." "E" => BobValue::GlobalVar("E".to_string()),
    "F." <name:LOWER> => BobValue::FrameVar(name.to_string()),
    "L." <name:LOWER> => BobValue::LineVar(name.to_string()),
};

// Readable variables
ReadableVar: BobValue = {
    <v:AssignableVar> => v,
    "T" => BobValue::EnvTempo,
    "R" => BobValue::EnvRandom,
    "I" => BobValue::InstanceVar("I".to_string()),
    "E" => BobValue::InstanceVar("E".to_string()),
    <s:UPPER> => BobValue::GlobalVar(s.to_string()),
    <s:LOWER> => BobValue::InstanceVar(s.to_string()),
};

VarRef: BobValue = {
    <v:ReadableVar> => v,
    <n:NOTE> => BobValue::Symbol(n[1..].to_lowercase()),
    ":" <s:LOWER> => BobValue::Symbol(s.to_string()),
};
