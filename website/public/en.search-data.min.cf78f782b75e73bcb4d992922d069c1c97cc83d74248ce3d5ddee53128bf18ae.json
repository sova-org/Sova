[{"id":0,"href":"/docs/tutoriels/","title":"Tutoriels","section":"Docs","content":" Tutoriels # Test de quelque chose\n"},{"id":1,"href":"/docs/documentation_technique/","title":"Documentation technique","section":"Docs","content":" Documentation technique # Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum Lorem ipsum\n"},{"id":2,"href":"/docs/apropos/","title":"À propos","section":"Docs","content":" À propos # Loïg Jezequel # Blabla\nTanguy Dubois # Blabla\nRaphaël Forment # Blabla\nRémi Georges # Blabla\n"},{"id":3,"href":"/posts/my-first-post/","title":"My First Post","section":"Posts","content":"Blabla bidule\n"},{"id":4,"href":"/docs/test/","title":"Test test","section":"Docs","content":"[ Messing Around with BILL\n** Custom Scripting Languages for BuboCore ** ]{align=\u0026ldquo;center\u0026rdquo;}\nAbstract. BuboCore has been designed so that it is (relatively) simple for a user to define their own scripting language(s) to be used for Live-Coding the steps of a pattern. The general idea is to write a compiler that will translate scripts to a low-level language \u0026ndash; BILL \u0026ndash; that is interpreted by the BuboCore scheduler. This requires to know BILL and to understand how the BuboCore scheduler works, which is the object of this document. At the end we also give a few guidelines on how to properly integrate a new scripting language into BuboCore.\n\\\nThe BuboCore scheduler # General overview # As show in [@fig]:overview, the scheduler is responsible for emitting (time-stamped) events. These events are mostly sent to the World, the interface between BuboCore and the different devices \u0026mdash; hardware or software \u0026mdash; that it controls. They can also occasionally be sent to other parts of BuboCore.\nFor that the scheduler loops forever, executing sequences of steps (each taken into a finite set of steps). The events that shall be emitted at each of these steps are specified as a sequence of instructions (a program) written in the BuboCore Intermediate Low-level Language (BILL). So, each step is associated to a BILL program.\nIn order to know how and when each step should occur, BuboCore scheduler relies on an environment that provides information on everything else (clocks, devices, etc).\nOverview of the BuboCore scheduler\n[]{#fig:overview}\nLifespan of a BILL program execution # Each step is always associated to a (potentially empty) BILL program. When the environment is such that a new step shall begin, the scheduler is responsible for instantiating a new execution of the BILL program associated to this step (as shown in [@fig]:steps where programs BP1, BP2 and BP3 respectively correspond to steps 1, 2 and 3). Once a program execution is instantiated, this program is executed by the scheduler until it is finished (that is, until a normal end of the program is reached, or until an error occurs in the program).\nNotice that the duration of a program execution is in general not related to the duration of the step in which it started: it may be shorter or longer. It is even possible that the same step occurs again before the end of the corresponding program execution, leading to two instances of the same program running at the same time (as for program BP2 in [@fig]:steps)\nA BILL program execution is instantiated at each step\n[]{#fig:steps}\nHow BILL programs are executed # A BILL program is a sequence of instructions ([@lst]:instruction) that can either be control instructions (a list of all the control instructions is given in [@sec]:control) or effect instructions (a list of all the effect instructions is given in [@sec]:effect).\npub enum Instruction { Control(ControlASM), Effect(Event, Variable), }\nInstruction definition\n[]{#lst:instruction}\nThe effect instructions are the ones that generate emissions of events to the World. Any effect instruction contains two parts: an event $e$ and a duration $d$ (in [@lst]:instruction this last part is represented by a Variable, this will be explained later). In the following, such an instruction is denoted by $(e,d)$.\nThe control instructions are all the other instructions: they are silent from the point of view of the World. In particular, the kind of instructions that one would expect to find in any assembly language (arithmetic and logic operations, control-flow management) are control instructions.\nExecution of a single program # In order to execute a program, the scheduler maintains a time counter that states when the next event can be emitted. This counter is initialized at the current time (so it is possible to emit an event at the very beginning of the program execution).\nThe scheduler then executes the program instructions one after the other in order. Depending of the kind of instruction reached by the scheduler, the execution is different:\na control instruction is executed as soon as it is reached;\nwhen an effect instruction $(e,d)$ is reached, the scheduler waits until the current time is equal or above the value of its time counter. As soon as this is the case the event $e$ is emitted and the time counter value is set to the sum of the current time and the duration $d$.\nThis means that control instructions are executed as fast as possible but that the delay between two effect instructions is at least equal to the duration of the first one (notice that this delay could be larger if the duration of the first effect instruction is shorter than the time needed to execute all the control instructions in between the two effect instructions).\nExecution of several programs in parallel # When several programs execute in parallel (as in step 3 in [@fig]:steps) each runs as described in [@sec]:execsingle. The scheduler executes, in turn, one instruction from each program. The order in which the programs are considered is the order in which they started their execution. In case a program shall execute an effect instruction but the time for the event emission has not yet been met, its turn is skipped (so it does not pause all the program executions).\nPattern, sequences, steps and some vocabulary # For the moment, we abstracted the exact way in which BuboCore scheduler handles steps. The idea is that there is an object that we call a pattern which is an array of objects called sequences. Each of these sequences is itself an array of steps. A step is constituted of a BILL program (that we call the program associated to this step) and a duration.\nThe BuboCore scheduler executes all the sequences in the pattern in parallel. For executing a sequence it starts at the first step in the array. Each steps is occurring for a time corresponding to its duration. At the end of a step, the scheduler switches to the next step in the same sequence. At the end of a sequence, the scheduler goes back to the start of this sequence. At the beginning of any step, the scheduler starts an execution of the corresponding BILL program. We call this execution an instance of the program.\nHow variables are handled # BILL programs can manipulate variables with control instructions and use them in effect instructions. These variables are of five kinds: environment variables, global variables, sequence variables, step variables and instance variables ([@lst]:variables).\npub enum Variable { Environment(String), Global(String), Sequence(String), Step(String), Instance(String), Constant(VariableValue), }\nKinds of variables\n[]{#lst:variables}\nTODO: changer les noms dans le code\nEnvironment variables # From the point of view of BILL programs, environment variables are read-only variables. Their values are set by the environment (think of time informations, random values, etc). A list of these variables is given in [@sec]:envvariables.\nGlobal variables # Global variables are shared among all the BILL program executions.\nSequence variables # Sequence variables are shared among all the BILL programs of a given sequence (the sequence in which they are declared). They cannot be seen by programs associated to steps from other sequences.\nStep variables # Step variables are shared among all the instances of the BILL program in which they are declared but are not seen by other programs.\nInstance variables # Ephemeral variables are local to the instance of BILL program in which they are declared. So, if several instances (parallel or not) of the same program exist, each of them has its own version of these variables.\nVariables with similar names # In BILL programs one refers to variables by their name but also has to explicitly state their kind. Therefore, there is no issue with variables of different kinds having the same name.\nA few words on functions # TODO: à écrire\nBILL: BuboCore Intermediate Low-level Language # In this section we describe all the control instructions ([@sec]:control) and all the effect instructions ([@sec]:effect) available in the BILL language. These instructions use variables and durations and we explain how they behave in [@sec]:variables and [@sec]:timing respectively. We also list the environment variables ([@sec]:envvariables).\nTypes of variables # Each variable (being environment, global, sequence, step, or instance) and constant has a type.\nExisting types # The possible types are given in [@lst]:types, which is an extract of the file\nsrc/lang/variable.rs .\npub enum VariableValue { Int(i64), Float(f64), Bool(bool), Str(String), Func(Program), Dur(TimeSpan), }\nTypes\n[]{#lst:types}\nTODO: je pense que ce serait bien d\u0026rsquo;uniformiser, genre Int, Float, Bool, Str, Func ou bien Integer, Floating, Boolean, String, Function. J\u0026rsquo;ai pris la première option, mais ce n\u0026rsquo;est peut-être pas possible en Rust si les types sont déjà utilisés ?\nIntegers, Float, Bool, Str and Dur variables are used to store values that can be read or written by the instructions of a program.\nFunc variables are programs themselves, they can be executed by calling them with the CallFunction control instruction. TODO: pas encore implanté\nType casting # TODO: est-ce que cet ajustement des types est déjà fait ? TODO: quand on met une valeur dans une variable =\u0026gt; caster au type de la variable TODO: quand on accède à une variable qui n\u0026rsquo;existe pas en lecture retourner valeur par défaut, en écriture créer la variable\nInstructions arguments are typed: each instruction expects a particular type for each of its input arguments (unless specified otherwise) and has to respect the type of its (potential) output argument when writing to it.\nIn order to avoid errors, values that have not the expected type will be casted to the correct type, following the rules given in [@tab]:casting. In this table, $\\bot$ denotes a function that does nothing (the program is an empty vector).\n+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ | **Fro | Int | ** | * | Str | * | Dur | | m\\To** | | Float** | Bool* | | Func* | | +=========+=========+=========+=========+=========+=========+=========+ | Int | | Repre | $ | D | $\\bot$ | A | | | | sented\\ | 0 \\righ | ecimal\\ | | bsolute | | | | as | tarrow | represe | | value | | | | float | \\text{f | ntation | | as | | | | | alse}$\\ | | | milli | | | | | $\\ne | | | seconds | | | | | q 0 \\ri | | | | | | | | ghtarro | | | | | | | | w \\text | | | | | | | | {true}$ | | | | +\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ | ** | R | | $ | D | $\\bot$ | A | | Float** | ounded\\ | | 0 \\righ | ecimal\\ | | bsolute | | | to int | | tarrow | represe | | value | | | | | \\text{f | ntation | | rounded | | | | | alse}$\\ | | | to int | | | | | $\\ne | | | as | | | | | q 0 \\ri | | | milli | | | | | ghtarro | | | seconds | | | | | w \\text | | | | | | | | {true}$ | | | | +\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ | * | $ | $\\t | | $\\tex | $\\bot$ | ? | | Bool* | \\text{f | ext{fal | | t{false | | | | | alse} \\ | se} \\ri | | } \\righ | | | | | rightar | ghtarro | | tarrow$ | | | | | row 0$\\ | w 0.0$\\ | | \u0026quot; | | | | | $\\text | $ | | False\u0026quot;\\ | | | | | {true} | \\text{t | | $\\te | | | | | \\righta | rue} \\r | | xt{true | | | | | rrow 1$ | ightarr | | } \\righ | | | | | | ow 1.0$ | | tarrow$ | | | | | | | | \u0026ldquo;True\u0026rdquo; | | | +\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ | Str | Parsed | Parsed | \u0026quot;\u0026quot; | | $\\bot$ | Parsed | | | as int\\ | as | $\\righ | | | as time | | | (0 if | float\\ | tarrow | | | d | | | error) | (0 if | \\text{f | | | uration | | | | error) | alse}$\\ | | | (0 if | | | | | $ | | | error) | | | | | \\neq$\u0026quot;\u0026quot; | | | | | | | | $\\ri | | | | | | | | ghtarro | | | | | | | | w \\text | | | | | | | | {true}$ | | | | +\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ | * | $\\bot \\ | $\\ | $\\bo | Name of | | ? | | Func* | rightar | bot \\ri | t \\righ | the\\ | | | | | row 0$\\ | ghtarro | tarrow | f | | | | | $\\ne | w 0.0$\\ | \\text{f | unction | | | | | q \\bot | $\\neq | alse}$\\ | | | | | | \\righta | \\bot \\r | $\\neq \\ | | | | | | rrow 1$ | ightarr | bot \\ri | | | | | | | ow 1.0$ | ghtarro | | | | | | | | w \\text | | | | | | | | {true}$ | | | | +\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ | Dur | Milli | Milli | $0$ms | Time as | $\\bot$ | | | | seconds | seconds | $\\righ | string | | | | | as int | repr | tarrow | | | | | | | esented | \\text{f | | | | | | | as | alse}$\\ | | | | | | | float | $\\n | | | | | | | | eq 0$ms | | | | | | | | $\\ri | | | | | | | | ghtarro | | | | | | | | w \\text | | | | | | | | {true}$ | | | | +\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+\u0026mdash;\u0026mdash;\u0026mdash;+ Type casting rules.\n[]{#tab:casting}\nDealing with durations # According to [@lst]:timespan (which is an extract of the file\nsrc/clock.rs ), variables representing durations can hold three kinds of values: microseconds, beats, and steps. A duration expressed as microseconds is an absolute time. A duration expressed as beats is a relative time: the exact duration depends on the number of microseconds in a beat. A duration expressed as steps is a relative time as well: the exact duration depends on the number of beats in the step associated to the BILL program in which the duration is used (that is, the step at which the program execution started). The duration of a beat or a step can be changed by BILL programs and by the environment.\npub enum TimeSpan { Micros(u64), Beats(f64), Steps(f64), }\nTimeSpan definition\n[]{#lst:timespan}\nConcrete durations are always expressed in microseconds. So, when a time-stamp must be associated to an event or when a delay must be applied the corresponding durations are converted to microseconds if needed. Before that, durations are always kept as general as possible: when an arithmetic operation is performed between two durations, the most concrete one is converted to the kind of the most general, as show in [@tab]:duration.\n**microseconds** **beats** **steps** microseconds microseconds beats steps beats beats steps steps steps\n: Result kinds in arithmetic operations between durations\n[]{#tab:duration}\nSometimes, one may want the result of a computation on durations not to be as general as possible, e.g to be evaluated as microseconds immediately, to prevent the duration to change with changes to the beat duration or to a step duration. For that, we provide operations to change the concreteness of a duration in [@sec]:control.\nControl instructions # Control instructions allow to perform basic operations (boolean and arithmetic) over variables. They also can change the control-flow of a program.\nConcretely, a BILL program is a vector of instructions. At any time, the next instruction to be executed is given by a position in this vector (think of the program counter for a processor) that the scheduler stores. After executing an instruction, by default this position is increased by one. To alter the control-flow, a few instructions allow to arbitrarily change this position (jump instructions) or even to change the vector that represents the current program (call and return instructions).\nThe existing control instructions are given in [@lst]:asm, which is an extract of the file\nsrc/lang/control_asm.rs .\npub enum ControlASM { // Arithmetic operations Add(Variable, Variable, Variable), Div(Variable, Variable, Variable), Mod(Variable, Variable, Variable), Mul(Variable, Variable, Variable), Sub(Variable, Variable, Variable), // Boolean operations And(Variable, Variable, Variable), Not(Variable, Variable), Or(Variable, Variable, Variable), Xor(Variable, Variable, Variable), // Bitwise operations BitAnd(Variable, Variable, Variable), BitNot(Variable, Variable), BitOr(Variable, Variable, Variable), BitXor(Variable, Variable, Variable), ShiftLeft(Variable, Variable, Variable), ShiftRightA(Variable, Variable, Variable), ShiftRightL(Variable, Variable, Variable), // String operations Concat(Variable, Variable, Variable), // Time manipulation AsBeats(Variable, Variable), AsMicros(Variable, Variable), AsSteps(Variable, Variable), // Memory manipulation DeclareGlobale(String, Variable), DeclareInstance(String, Variable), DeclareSequence(String, Variable), DeclareStep(String, Variable), Mov(Variable, Variable), // Jumps Jump(usize), JumpIf(Variable, usize), JumpIfDifferent(Variable, Variable, usize), JumpIfEqual(Variable, Variable, usize), JumpIfLess(Variable, Variable, usize), JumpIfLessOrEqual(Variable, Variable, usize), // Calls and returns CallFunction(Variable), CallProcedure(usize), Return, }\nControl instructions\n[]{#lst:asm}\nArithmetic operations # These instructions are all of the form\nOp(x, y, z) . Arguments x and y are inputs and z is an output. It is expected that x and y are two numbers of the same type (Int, Float or Dur). If this is not the case:\nif x is a number y will be casted to the type of x,\nelse if y is a number x will be casted to the type of y,\nelse they will both be casted to Int.\nThe result of the operation will be casted to the type of z (if needed).\nEach instruction performs a different operation, as shown in [@tab]:arithmetic.\n+\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Op | Semantics | Remark | +========+=============================+=============================+ | Add | $z \\leftarrow x + y$ | | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Div | $z \\leftarrow x/y$ | $z \\leftarrow 0$ if $y = 0$ | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Mod | $z \\left | $z \\leftarrow x$ if | | | arrow x\\operatorname{mod}y$ | $y = 0$\\ | | | | $z \\leftarrow 0$ if $y$ is | | | | a float | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Mul | $z \\leftarrow x \\times y$ | | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Sub | $z \\leftarrow x - y$ | | +\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ Arithmetic operations semantics\n[]{#tab:arithmetic}\nBoolean operations # These instructions are all of the form\nOp(x, y, z) or\nOp(x, z) . Arguments x and y are inputs and will be casted to bool (if needed). Argument z is an output. The result of the operation will be casted to the type of z (if needed).\nEach instruction performs a different operation, as shown in [@tab]:boolean.\nOp Semantics Remark\nAnd $z \\leftarrow x \\land y$ Not $z \\leftarrow \\neg x$ Or $z \\leftarrow x \\vee y$ Xor $z \\leftarrow x \\oplus y$\n: Boolean operations semantics\n[]{#tab:boolean}\nBitwise operations # These instructions are all of the form\nOp(x, y, z) or\nOp(x, z) . Arguments x and y are inputs and will be casted to int (if needed). Argument z is an output. The result of the operation will be casted to the type of z (if needed).\nEach instruction performs a different operation, as shown in [@tab]:bitwise.\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | Op | Semantics | Remark | +=============+=========================+=============================+ | BitAnd | $z \\leftarrow x\u0026amp; y$ | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | BitNot | $z \\leftarrow \\sim x$ | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | BitOr | $z \\leftarrow x~|~y$ | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | BitXor | $z \\leftarrow x\\hat{}y$ | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | ShiftLeft | $z \\leftarrow x \\ll y$ | $z \\leftarrow x$ if $y \u0026lt; 0$ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | ShiftRightA | $z \\leftarrow x \\gg y$ | arithmetic shift\\ | | | | $z \\leftarrow x$ if $y \u0026lt; 0$ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | ShiftRightL | $z \\leftarrow x \\gg y$ | logical shift\\ | | | | $z \\leftarrow x$ if $y \u0026lt; 0$ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ Bitwise operations semantics (C-like syntax)\n[]{#tab:bitwise}\nString operations # These instructions are all of the form\nOp(x, y, z) . Arguments x and y are inputs and will be casted to str (if needed). Argument z is an output. The result of the operation will be casted to the type of z (if needed).\nEach instruction performs a different operation, as shown in [@tab]:string.\nOp Semantics Remark\nConcat $z \\leftarrow x.y$ string concatenation\n: String operations semantics\n[]{#tab:string}\nTime manipulation # These instructions allow to perform conversions on durations.\nAsMicros(d, v). Casts $d$ to a duration. Set this duration to microseconds, cast it to the type of $v$, and then store it in $v$.\nAsBeats(d, v). Casts $d$ to a duration. Set this duration to beats, cast it to the type of $v$, and then store it in $v$.\nAsSteps(d, v). Casts $d$ to a duration. Set this duration to steps, cast it to the type of $v$, and then store it in $v$.\nMemory manipulation # The four variable declaration instructions (DeclareGlobal, DeclareInstance, DeclareSequence, DeclareStep) are of the form\nDeclare(name, value) and will create a new (Global, Instance, Sequence or Step) variable named\nname and initialize its value to\nvalue . The type of the new variable is the type of\nvalue .\nNotice that, in any program instruction arguments, if a variable that does not exist is read this will give a 0 value. If a variable that does not exist is written, the variable will be created. (except if it is an environment variable, writing to environment variables has no effect).\nThe\nmov(x, z) instruction semantics is $z \\leftarrow x$. If needed, the value of\nx will be casted to the type of\nz .\nJumps # By default, the instructions of a BILL program are executed one after the other in the order in which they are stored in the vector representing the program. At each time, the position of the instruction to be executed is stored by the scheduler (think of a program counter for a processor). Assume that the place where this position is stored is called\npc . By default, after executing an instruction, the scheduler increases\npc : $\\text{pc } \\leftarrow \\text{ pc} + 1$. Jump instructions allow to replace this standard update of\npc by something else, potentially based on a condition.\nThe semantics of the different jump instructions is given in [@tab]:jumps. In each case, if the condition is $\\text{true}$ then $\\text{pc } \\leftarrow d\\operatorname{mod}n$ (where $n$ is the number of instructions in the program). Else, $\\text{pc } \\leftarrow \\text{ pc } + 1$.\nInstruction Cond. Remark\nJump(d) $\\text{true}$\nJumpIf(x, d) $x$ $x$ casted to Bool JumpIfDifferent(x, y, d) $x \\neq y$ $y$ casted to the type of $x$ JumpIfEqual(x, y, d) $x = y$ $y$ casted to the type of $x$ JumpIfLess(x, y, d) $x \u0026lt; y$ $y$ casted to the type of $x$ JumpIfLessOrEqual(x, y, d) $x \\leq y$ $y$ casted to the type of $x$\n: Jumps semantics\n[]{#tab:jumps}\nCalls and returns # TODO: pas mal de trucs à rajouter dans le scheduler pour gérer ça\nA jump instruction always jumps to the same position in a program. Hence, one cannot use them to simulate procedure calls (the return position from a procedure depends on the point in code at which the jump to the procedure happened).\nCalls are jumps that store, in a stack, the position from which they jumped. Returns are jumps that read in this stack to determine the position to which they jump. This stack will be called return stack.\nCallFunction(f). Cast $f$ to a program, then replace the current program $p$ with $f$. Push ($p,\\text{ pc } + 1)$ into the return stack. Set\npc to 0 (the start of the new program).\nCallProcedure(pos). Push $\\left( p,\\text{ pc } + 1 \\right)$ (where $p$ is the current program) into the return stack. Set\npc to pos.\nReturn. Pop $\\left( p,\\text{ pos} \\right)$ from the return stack. Replace the current program with $p$ (if needed) and set\npc to pos. If the return stack is empty when using return, the program will end.\nEffect instructions # Effect instructions are constituted of an Event and a TimeSpan ([@lst]:instruction). The Event describes the effect of the instruction on the World and the TimeSpan tells how much time shall elapse after the event occurs.\nThe existing events are given in [@lst]:event, which is an extract of the file\nsrc/lang/event.rs .\nIn this section we give the semantics of these events.\npub enum Event { // Meta Nop, List(Vec\u0026lt;Event\u0026gt;), // Music PlayChord(Vec\u0026lt;Variable\u0026gt;, Variable), // Time handling SetBeatDuration(Variable), SetCurrentStepDuration(Variable), SetStepDuration(Variable, Variable), // Program starting Continue, ContinueInstance(Variable), ContinueOldest(Variable), ContinueSequence(Variable), ContinueSequenceOldest(Variable), ContinueSequenceYoungest(Variable), ContinueStep(Variable), ContinueStepOldest(Variable, Variable), ContinueStepYoungest(Variable, Variable), ContinueYoungest(Variable), Start(Variable, Variable), // Program halting Pause, PauseInstance(Variable), PauseOldest(Variable), PauseSequence(Variable), PauseSequenceOldest(Variable, Variable), PauseSequenceYoungest(Variable, Variable), PauseStep(Variable), PauseStepOldest(Variable, Variable), PauseStepYoungest(Variable, Variable), PauseYoungest(Variable), Stop, StopInstance(Variable), StopOldest(Variable), StopSequence(Variable), StopSequenceOldest(Variable, Variable), StopSequenceYoungest(Variable, Variable), StopStep(Variable), StopStepOldest(Variable, Variable), StopStepYoungest(Variable, Variable), StopYoungest(Variable), }\nEvent definition\n[]{#lst:event}\nMeta events # Nop. Does nothing.\nList(e). Performs all the events in $e$ as fast as possible (that is, kind of simultaneously it there are not too much events in $e$), in the order in which they are given.\nMusic events # Music events are the events that actually allow to play sound on a given device. Not all devices accept all events.\nPlayChord(notes, d). Plays all the notes given in notes (casted to int used as midi values) together for $d$ (casted to a duration and set to milliseconds) milliseconds.\nTime handling events # Time handling events allow to manage the relations between beats, step duration, and absolute time.\nSetBeatDuration(t). Sets the duration of one beat to $t$ (casted to a duration). This duration is set in milliseconds (absolute time) by first evaluating $t$ in milliseconds. The standard use is to give $t$ in milliseconds to setup a tempo. However, one could give $t$ in beats for relative change of tempo (if $t$ is 3 beats the tempo is divided by 3 as the duration of a beat is multiplied by 3).\nSetCurrentStepDuration(t). Sets the duration of the step associated to the program instance calling this instruction to $t$ (casted to a duration). This duration is set in beats if possible or, else, it is set in milliseconds. The standard use is to give $t$ in beats, so that if beat duration changes step duration changes accordingly. However one could give $t$ in milliseconds to avoid this side effect.\nSetStepDuration(n, t). Same as SetCurrentStepDuration but for step $n$ (casted to an int). See [@sec]:envvariables for knowing how to get step numbers.\nProgram starting events # Starting events allow to initiate new program instances (start) and to resume execution of program instances that were previously paused (continue). How program instances can be paused is described in [@sec]:halting.\nContinue. Resumes all currently paused program instances.\nContinueInstance(n). Resumes the program instance with number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get instance numbers.\nContinueOldest(k). Resumes the $k$ (casted to an int) program instances that were paused the longest time ago.\nContinueSequence(n). Resumes all currently paused program instances corresponding to steps in sequence $n$ (casted to an int). See [@sec]:envvariables for knowing how to get sequence numbers.\nContinueSequenceOldest(n, k). Resumes the $k$ (casted to an int) program instances corresponding to steps in sequence $n$ (casted to an int) that were paused the longest time ago. See [@sec]:envvariables for knowing how to get sequence numbers.\nContinueSequenceYoungest(n, k). Resumes the $k$ (casted to an int) program instances corresponding to steps in sequence $n$ (casted to an int) that were paused the shortest time ago. See [@sec]:envvariables for knowing how to get sequence numbers.\nContinueStep(n). Resumes all currently paused program instances corresponding to step $n$ (casted to an int). See [@sec]:envvariables for knowing how to get step numbers.\nContinueStepOldest(n, k). Resumes the $k$ (casted to an int) program instances corresponding to step $n$ (casted to an int) that were paused the longest time ago. See [@sec]:envvariables for knowing how to get step numbers.\nContinueStepYoungest(n, k). Resumes the $k$ (casted to an int) program instances corresponding to step $n$ (casted to an int) that were paused the shortest time ago. See [@sec]:envvariables for knowing how to get step numbers.\nContinueYoungest(k). Resumes the $k$ (casted to an int) program instances that were paused the shortest time ago.\nStart(p, i). Starts a new instance of program $p$. If $p$ is a function, then this function is used as a program. Else the program corresponding to step $p$ (casted to an int) is used. The number of the new instance is recorded in $i$ (after casting it to the type of $i$). Remark that such a program instance is not associated to any step or sequence. TODO: est-ce que ça ne devrait pas être associé au step depuis lequel l\u0026rsquo;instruction est appelée ? ou alors pouvoir donner un step en paramètre ?\nProgram halting events # Halting events are of two kinds: stop events and pause events. Stop events will end the execution of a (set of) program(s) instance(s). Pause events will pause the execution of a (set of) program(s) instance(s) allowing to continue their execution from the point at which they where paused using program starting events ([@sec]:starting).\nWe describe here the stop events as the corresponding pause events have the same behavior.\nStop. Stops all the program instances currently running.\nStopInstance(n). Stops the program instance with number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get instance numbers.\nStopOldest(k). Stops the $k$ (casted to an int) oldest program instances (that started the longest time ago).\nStopSequence(n). Stops all the program instances corresponding to steps in sequence number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get sequence numbers.\nStopSequenceOldest(n, k). Stops the $k$ (casted to an int) oldest program instances (that started the longest time ago) corresponding to steps in sequence number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get sequence numbers.\nStopSequenceYoungest(n, k). Stops the $k$ (casted to an int) youngest program instances (that started the shortest time ago) corresponding to steps in sequence number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get sequence numbers.\nStopStep(n). Stops all the program instances corresponding to step number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get step numbers.\nStopStepOldest(n, k). Stops the $k$ (casted to an int) oldest program instances (that started the longest time ago) corresponding to step number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get step numbers.\nStopStepYoungest(n, k). Stops the $k$ (casted to an int) youngest program instances (that started the shortest time ago) corresponding to step number $n$ (casted to an int). See [@sec]:envvariables for knowing how to get step numbers.\nStopYoungest(k). Stops the $k$ (casted to an int) youngest program instances (that started the shortest time ago).\nEnvironment variables # TODO: on aurait envie d\u0026rsquo;avoir des variables d\u0026rsquo;environnement qui sont des ensembles, comment faire ? Ça demande sans doute d\u0026rsquo;ajouter un type de variable ? On voudrait aussi paramétrer les variables d\u0026rsquo;environnement mais en l\u0026rsquo;état ce n\u0026rsquo;est pas trop possible (par exemple pour obtenir le nombre de pas dans la séquence n), la version actuelle ne fonctionne pas vraiment car on ne peut pas construire les noms de variable dans un programme BILL. Il faut peut-être que les variables en question soient remplacées par des évènements (getters)\nTODO: à ajouter dans l\u0026rsquo;outil (mais pas tout de suite, il faut d\u0026rsquo;abord voir comment ça devrait marcher exactement)\nThe environment variables provided by BuboCore are given below. Some of them are parameterized for simplicity. Parameters are depicted here between dollars signs, they should be replaced by integers. For example, Sequence$n$NumSteps corresponds to the variables Sequence1NumSteps, Sequence2NumSteps, and so on.\nInstanceID. ID of this program instance.\nInstance$n$SequenceID. ID of the sequence containing the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$SequenceBeats. Number of beats in the sequence containing the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$SequenceMicros. Number of microseconds in the sequence containing the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$StepID. ID of the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$StepBeats. Number of beats in the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$StepMicros. Number of microseconds in the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$SequenceNumInstances. Same as NumInstances but only for instances corresponding to the sequence containing the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$SequenceNumRunning. Same as NumRunning but only for instances corresponding to the sequence containing the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$SequenceNumPaused. Same as NumPaused but only for instances corresponding to the sequence containing the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$StepNumInstances. Same as NumInstances but only for instances corresponding to the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$StepNumRunning. Same as NumRunning but only for instances corresponding to the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nInstance$n$StepNumPaused. Same as NumPaused but only for instances corresponding to the step associated to the program instance number $n$ (or the instance of the program using this variable if $n$ is omitted).\nNumInstances. Number of instances currently running or paused.\nNumPaused. Number of instances currently paused.\nNumRunning. Number of instances currently running.\nNumSequences. Number of sequences.\nSequence$n$NumSteps. Number of steps in sequence number $n$.\nSequenceID. ID of the sequence containing the step corresponding to this program.\nSequence$n$Beats. Number of beats in the sequence number $n$ (or the sequence containing the step associated to the program using this variable if $n$ is omitted).\nSequence$n$Micros. Number of microseconds in the sequence number $n$ (or the sequence containing the step associated to the program using this variable if $n$ is omitted).\nSequence$n$NumInstances. Same as NumInstances but only for instances corresponding to the sequence number $n$ (or the sequence containing the step associated to the program using this variable if $n$ is omitted).\nSequence$n$NumRunning. Same as NumRunning but only for instances corresponding to the sequence number $n$ (or the sequence containing the step associated to the program using this variable if $n$ is omitted).\nSequence$n$NumPaused. Same as NumPaused but only for instances corresponding to the sequence number $n$ (or the sequence containing the step associated to the program using this variable if $n$ is omitted).\nStepID. ID of the step corresponding to this program.\nStep$n$SequenceID. ID of the sequence containing the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$SequenceBeats. Number of beats in the sequence containing the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$SequenceMicros. Number of microseconds in the sequence containing the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$Beats. Number of beats in the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$Micros. Number of microseconds in the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$NumInstances. Same as NumInstances but only for instances corresponding to the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$NumRunning. Same as NumRunning but only for instances corresponding to the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$NumPaused. Same as NumPaused but only for instances corresponding to the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$SequenceNumInstances. Same as NumInstances but only for instances corresponding to the sequence containing the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$SequenceNumRunning. Same as NumRunning but only for instances corresponding to the sequence containing the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nStep$n$SequenceNumPaused. Same as NumPaused but only for instances corresponding to the sequence containing the step number $n$ (or the step associated to the program using this variable if $n$ is omitted).\nTotalBeats. Number of beats since the launch of BuboCore.\nTotalMicros. Number of microseconds since the launch of BuboCore. This cannot be computed from TotalBeats as the duration of a beat may have changed over time.\nBeatMicros. Number of microseconds in a beat.\nGuidelines for building a custom scripting language # In order to build a custom scripting language one needs to be able to compile it to BILL. There are two possibilities for writing a compiler compatible with BuboCore:\ncompilers written in RUST can be integrated as modules of BuboCore, and\ncompilers built with any technology can be provided as binaries that BuboCore will call.\nThe first method is preferred as it allows to directly build BILL programs as RUST data-structures and ensures a better integration into BuboCore. It also allows to easily distribute new scripting languages: a simple pull request on our Github repository1 will let us integrate any scripting language into the next versions of BuboCore.\nCompiler integration into BuboCore # Building a custom scripting langage requires to know how to build BuboCore, please refer to the appropriate document2 for that part.\nIn order to add a compiler for a new script language one has to comply with the following guidelines:\ncreate a directory with the name of the language in\nsrc/compiler/ and implement the\ncompiler trait by providing a\ncompile function that given a script in the language (provided as a string) produces the corresponding BILL code,\ncreate a\n.rs file with the name of the language in\nsrc/compiler/ and export (\npub use ) the\ncompiler implementation,\ndeclare the new module (\npub mod ) in the\nsrc/compiler.rs file.\nAs an example, one can have a look at the dummylang language that has been created for testing purposes while developing BuboCore:\nthe compiler trait is implemented in\nsrc/compiler/dummylang/dummycompiler.rs ,\nit is exported in\nsrc/compiler/dummylang/dummylang.rs by the line\npub use dummycompiler::DummyCompiler; ,\nit is declared in\nsrc/compiler.rs by the line\npub mod dummylang; .\nCompiler as a standalone binary # TODO: regarder comment ça marche et faire un exemple\nhttps://github.com/Bubobubobubobubo/deep-bubocore\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nTODO (quand la doc pour construire BuboCore sera écrite il faudra la référencer ici)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"}]