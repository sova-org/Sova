<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="[ Messing Around with BILL
** Custom Scripting Languages for BuboCore ** ]{align=&ldquo;center&rdquo;}

Abstract. BuboCore has been designed so that it is (relatively)
simple for a user to define their own scripting language(s) to be used
for Live-Coding the steps of a pattern. The general idea is to write a
compiler that will translate scripts to a low-level language &ndash; BILL &ndash;
that is interpreted by the BuboCore scheduler. This requires to know
BILL and to understand how the BuboCore scheduler works, which is the
object of this document. At the end we also give a few guidelines on how
to properly integrate a new scripting language into BuboCore.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/test/">
  <meta property="og:site_name" content="BuboCore">
  <meta property="og:title" content="Test test">
  <meta property="og:description" content="[ Messing Around with BILL
** Custom Scripting Languages for BuboCore ** ]{align=“center”}
Abstract. BuboCore has been designed so that it is (relatively) simple for a user to define their own scripting language(s) to be used for Live-Coding the steps of a pattern. The general idea is to write a compiler that will translate scripts to a low-level language – BILL – that is interpreted by the BuboCore scheduler. This requires to know BILL and to understand how the BuboCore scheduler works, which is the object of this document. At the end we also give a few guidelines on how to properly integrate a new scripting language into BuboCore.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>Test test | BuboCore</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/test/">
<link rel="stylesheet" href="/book.min.b9a006882a5869d40c671d6797491ce2d17e0bfc9bdf5f250c31e6c085d435e5.css" integrity="sha256-uaAGiCpYadQMZx1nl0kc4tF&#43;C/yb318lDDHmwIXUNeU=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.9b7c15cec688e18e95eec091d4e99594c22537de0af89b2d534b1ac82f08b2ea.js" integrity="sha256-m3wVzsaI4Y6V7sCR1OmVlMIlN94K&#43;JstU0sayC8Isuo=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/bubobubo.jpg" alt="Logo" class="book-icon" /><span>BuboCore</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  



  
  <ul>
    
      
        <li>
          
  
  

  
    <span>Posts</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/posts/my-first-post/" class="">My First Post</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Docs</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tutoriels/" class="">Tutoriels</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/apropos/" class="">À propos</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/test/" class="active">Test test</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Test test</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#general-overview">General overview</a></li>
    <li><a href="#lifespan-of-a-bill-program-execution">Lifespan of a BILL program execution</a></li>
    <li><a href="#how-bill-programs-are-executed">How BILL programs are executed</a>
      <ul>
        <li><a href="#sec:execsingle">Execution of a single program</a></li>
        <li><a href="#execution-of-several-programs-in-parallel">Execution of several programs in parallel</a></li>
      </ul>
    </li>
    <li><a href="#pattern-sequences-steps-and-some-vocabulary">Pattern, sequences, steps and some vocabulary</a></li>
    <li><a href="#how-variables-are-handled">How variables are handled</a>
      <ul>
        <li><a href="#environment-variables">Environment variables</a></li>
        <li><a href="#global-variables">Global variables</a></li>
        <li><a href="#sequence-variables">Sequence variables</a></li>
        <li><a href="#step-variables">Step variables</a></li>
        <li><a href="#instance-variables">Instance variables</a></li>
        <li><a href="#variables-with-similar-names">Variables with similar names</a></li>
      </ul>
    </li>
    <li><a href="#a-few-words-on-functions">A few words on functions</a></li>
  </ul>

  <ul>
    <li><a href="#sec:variables">Types of variables</a>
      <ul>
        <li><a href="#existing-types">Existing types</a></li>
        <li><a href="#type-casting">Type casting</a></li>
      </ul>
    </li>
    <li><a href="#sec:timing">Dealing with durations</a></li>
    <li><a href="#sec:control">Control instructions</a>
      <ul>
        <li><a href="#arithmetic-operations">Arithmetic operations</a></li>
        <li><a href="#boolean-operations">Boolean operations</a></li>
        <li><a href="#bitwise-operations">Bitwise operations</a></li>
        <li><a href="#string-operations">String operations</a></li>
        <li><a href="#time-manipulation">Time manipulation</a></li>
        <li><a href="#memory-manipulation">Memory manipulation</a></li>
        <li><a href="#jumps">Jumps</a></li>
        <li><a href="#calls-and-returns">Calls and returns</a></li>
      </ul>
    </li>
    <li><a href="#sec:effect">Effect instructions</a>
      <ul>
        <li><a href="#meta-events">Meta events</a></li>
        <li><a href="#music-events">Music events</a></li>
        <li><a href="#time-handling-events">Time handling events</a></li>
        <li><a href="#sec:starting">Program starting events</a></li>
        <li><a href="#sec:halting">Program halting events</a></li>
      </ul>
    </li>
    <li><a href="#sec:envvariables">Environment variables</a></li>
  </ul>

  <ul>
    <li><a href="#compiler-integration-into-bubocore">Compiler integration into BuboCore</a></li>
    <li><a href="#compiler-as-a-standalone-binary">Compiler as a standalone binary</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><p>[ <strong>Messing Around with BILL</strong><br>
** Custom Scripting Languages for BuboCore ** ]{align=&ldquo;center&rdquo;}</p>
<p><br>
<strong>Abstract.</strong> BuboCore has been designed so that it is (relatively)
simple for a user to define their own scripting language(s) to be used
for Live-Coding the steps of a pattern. The general idea is to write a
compiler that will translate scripts to a low-level language &ndash; BILL &ndash;
that is interpreted by the BuboCore scheduler. This requires to know
BILL and to understand how the BuboCore scheduler works, which is the
object of this document. At the end we also give a few guidelines on how
to properly integrate a new scripting language into BuboCore.</p>
<p>\</p>
<h1 id="the-bubocore-scheduler">
  The BuboCore scheduler
  <a class="anchor" href="#the-bubocore-scheduler">#</a>
</h1>
<h2 id="general-overview">
  General overview
  <a class="anchor" href="#general-overview">#</a>
</h2>
<p>As show in [@fig]:overview, the scheduler is responsible for emitting
(time-stamped) events. These events are mostly sent to the World, the
interface between BuboCore and the different devices &mdash; hardware or
software &mdash; that it controls. They can also occasionally be sent to
other parts of BuboCore.</p>
<p>For that the scheduler loops forever, executing sequences of steps (each
taken into a finite set of steps). The events that shall be emitted at
each of these steps are specified as a sequence of instructions (a
program) written in the BuboCore Intermediate Low-level Language (BILL).
So, each step is associated to a BILL program.</p>
<p>In order to know how and when each step should occur, BuboCore scheduler
relies on an environment that provides information on everything else
(clocks, devices, etc).</p>
<figure>
<p><img src="sched.png" style="width:80.0%" /></p>
<figcaption><p>Overview of the BuboCore scheduler</p></figcaption>
</figure>
<p>[]{#fig:overview}</p>
<h2 id="lifespan-of-a-bill-program-execution">
  Lifespan of a BILL program execution
  <a class="anchor" href="#lifespan-of-a-bill-program-execution">#</a>
</h2>
<p>Each step is always associated to a (potentially empty) BILL program.
When the environment is such that a new step shall begin, the scheduler
is responsible for instantiating a new execution of the BILL program
associated to this step (as shown in [@fig]:steps where programs BP1,
BP2 and BP3 respectively correspond to steps 1, 2 and 3). Once a program
execution is instantiated, this program is executed by the scheduler
until it is finished (that is, until a normal end of the program is
reached, or until an error occurs in the program).</p>
<p>Notice that the duration of a program execution is in general not
related to the duration of the step in which it started: it may be
shorter or longer. It is even possible that the same step occurs again
before the end of the corresponding program execution, leading to two
instances of the same program running at the same time (as for program
BP2 in [@fig]:steps)</p>
<figure>
<p><img src="steps.png" style="width:80.0%" /></p>
<figcaption><p>A BILL program execution is instantiated at each
step</p></figcaption>
</figure>
<p>[]{#fig:steps}</p>
<h2 id="how-bill-programs-are-executed">
  How BILL programs are executed
  <a class="anchor" href="#how-bill-programs-are-executed">#</a>
</h2>
<p>A BILL program is a sequence of <em>instructions</em> ([@lst]:instruction) that
can either be <em>control</em> instructions (a list of all the control
instructions is given in [@sec]:control) or <em>effect</em> instructions (a
list of all the effect instructions is given in [@sec]:effect).</p>
<figure>
<p><code>pub enum Instruction {
    Control(ControlASM),
    Effect(Event, Variable),
}</code></p>
<figcaption><p>Instruction definition</p></figcaption>
</figure>
<p>[]{#lst:instruction}</p>
<p>The effect instructions are the ones that generate emissions of events
to the World. Any effect instruction contains two parts: an event $e$
and a duration $d$ (in [@lst]:instruction this last part is represented
by a Variable, this will be explained later). In the following, such an
instruction is denoted by $(e,d)$.</p>
<p>The control instructions are all the other instructions: they are silent
from the point of view of the World. In particular, the kind of
instructions that one would expect to find in any assembly language
(arithmetic and logic operations, control-flow management) are control
instructions.</p>
<h3 id="sec:execsingle">
  Execution of a single program
  <a class="anchor" href="#sec:execsingle">#</a>
</h3>
<p>In order to execute a program, the scheduler maintains a time counter
that states when the next event can be emitted. This counter is
initialized at the current time (so it is possible to emit an event at
the very beginning of the program execution).</p>
<p>The scheduler then executes the program instructions one after the other
in order. Depending of the kind of instruction reached by the scheduler,
the execution is different:</p>
<ul>
<li>
<p>a control instruction is executed as soon as it is reached;</p>
</li>
<li>
<p>when an effect instruction $(e,d)$ is reached, the scheduler waits
until the current time is equal or above the value of its time
counter. As soon as this is the case the event $e$ is emitted and the
time counter value is set to the sum of the current time and the
duration $d$.</p>
</li>
</ul>
<p>This means that control instructions are executed as fast as possible
but that the delay between two effect instructions is at least equal to
the duration of the first one (notice that this delay could be larger if
the duration of the first effect instruction is shorter than the time
needed to execute all the control instructions in between the two effect
instructions).</p>
<h3 id="execution-of-several-programs-in-parallel">
  Execution of several programs in parallel
  <a class="anchor" href="#execution-of-several-programs-in-parallel">#</a>
</h3>
<p>When several programs execute in parallel (as in step 3 in [@fig]:steps)
each runs as described in [@sec]:execsingle. The scheduler executes, in
turn, one instruction from each program. The order in which the programs
are considered is the order in which they started their execution. In
case a program shall execute an effect instruction but the time for the
event emission has not yet been met, its turn is skipped (so it does not
pause all the program executions).</p>
<h2 id="pattern-sequences-steps-and-some-vocabulary">
  Pattern, sequences, steps and some vocabulary
  <a class="anchor" href="#pattern-sequences-steps-and-some-vocabulary">#</a>
</h2>
<p>For the moment, we abstracted the exact way in which BuboCore scheduler
handles steps. The idea is that there is an object that we call a
<em>pattern</em> which is an array of objects called <em>sequences</em>. Each of these
sequences is itself an array of <em>steps</em>. A step is constituted of a BILL
program (that we call the program <em>associated</em> to this step) and a
duration.</p>
<p>The BuboCore scheduler executes all the sequences in the pattern in
parallel. For executing a sequence it starts at the first step in the
array. Each steps is occurring for a time corresponding to its duration.
At the end of a step, the scheduler switches to the next step in the
same sequence. At the end of a sequence, the scheduler goes back to the
start of this sequence. At the beginning of any step, the scheduler
starts an execution of the corresponding BILL program. We call this
execution an <em>instance</em> of the program.</p>
<h2 id="how-variables-are-handled">
  How variables are handled
  <a class="anchor" href="#how-variables-are-handled">#</a>
</h2>
<p>BILL programs can manipulate variables with control instructions and use
them in effect instructions. These variables are of five kinds:
environment variables, global variables, sequence variables, step
variables and instance variables ([@lst]:variables).</p>
<figure>
<p><code>pub enum Variable {
    Environment(String),
    Global(String),
    Sequence(String),
    Step(String),
    Instance(String),
    Constant(VariableValue),
}</code></p>
<figcaption><p>Kinds of variables</p></figcaption>
</figure>
<p>[]{#lst:variables}</p>
<p>TODO: changer les noms dans le code</p>
<h3 id="environment-variables">
  Environment variables
  <a class="anchor" href="#environment-variables">#</a>
</h3>
<p>From the point of view of BILL programs, environment variables are
read-only variables. Their values are set by the environment (think of
time informations, random values, etc). A list of these variables is
given in [@sec]:envvariables.</p>
<h3 id="global-variables">
  Global variables
  <a class="anchor" href="#global-variables">#</a>
</h3>
<p>Global variables are shared among all the BILL program executions.</p>
<h3 id="sequence-variables">
  Sequence variables
  <a class="anchor" href="#sequence-variables">#</a>
</h3>
<p>Sequence variables are shared among all the BILL programs of a given
sequence (the sequence in which they are declared). They cannot be seen
by programs associated to steps from other sequences.</p>
<h3 id="step-variables">
  Step variables
  <a class="anchor" href="#step-variables">#</a>
</h3>
<p>Step variables are shared among all the instances of the BILL program in
which they are declared but are not seen by other programs.</p>
<h3 id="instance-variables">
  Instance variables
  <a class="anchor" href="#instance-variables">#</a>
</h3>
<p>Ephemeral variables are local to the instance of BILL program in which
they are declared. So, if several instances (parallel or not) of the
same program exist, each of them has its own version of these variables.</p>
<h3 id="variables-with-similar-names">
  Variables with similar names
  <a class="anchor" href="#variables-with-similar-names">#</a>
</h3>
<p>In BILL programs one refers to variables by their name but also has to
explicitly state their kind. Therefore, there is no issue with variables
of different kinds having the same name.</p>
<h2 id="a-few-words-on-functions">
  A few words on functions
  <a class="anchor" href="#a-few-words-on-functions">#</a>
</h2>
<p>TODO: à écrire</p>
<h1 id="bill-bubocore-intermediate-low-level-language">
  BILL: BuboCore Intermediate Low-level Language
  <a class="anchor" href="#bill-bubocore-intermediate-low-level-language">#</a>
</h1>
<p>In this section we describe all the control instructions
([@sec]:control) and all the effect instructions ([@sec]:effect)
available in the BILL language. These instructions use variables and
durations and we explain how they behave in [@sec]:variables and
[@sec]:timing respectively. We also list the environment variables
([@sec]:envvariables).</p>
<h2 id="sec:variables">
  Types of variables
  <a class="anchor" href="#sec:variables">#</a>
</h2>
<p>Each variable (being environment, global, sequence, step, or instance)
and constant has a type.</p>
<h3 id="existing-types">
  Existing types
  <a class="anchor" href="#existing-types">#</a>
</h3>
<p>The possible types are given in [@lst]:types, which is an extract of the
file</p>
<pre><code>src/lang/variable.rs
</code></pre>
<p>.</p>
<figure>
<p><code>pub enum VariableValue {
    Int(i64),
    Float(f64),
    Bool(bool),
    Str(String),
    Func(Program),
    Dur(TimeSpan),
  }</code></p>
<figcaption><p>Types</p></figcaption>
</figure>
<p>[]{#lst:types}</p>
<p>TODO: je pense que ce serait bien d&rsquo;uniformiser, genre Int, Float, Bool,
Str, Func ou bien Integer, Floating, Boolean, String, Function. J&rsquo;ai
pris la première option, mais ce n&rsquo;est peut-être pas possible en Rust si
les types sont déjà utilisés ?</p>
<p>Integers, Float, Bool, Str and Dur variables are used to store values
that can be read or written by the instructions of a program.</p>
<p>Func variables are programs themselves, they can be executed by calling
them with the CallFunction control instruction. TODO: pas encore
implanté</p>
<h3 id="type-casting">
  Type casting
  <a class="anchor" href="#type-casting">#</a>
</h3>
<p>TODO: est-ce que cet ajustement des types est déjà fait ? TODO: quand on
met une valeur dans une variable =&gt; caster au type de la variable TODO:
quand on accède à une variable qui n&rsquo;existe pas en lecture retourner
valeur par défaut, en écriture créer la variable</p>
<p>Instructions arguments are typed: each instruction expects a particular
type for each of its input arguments (unless specified otherwise) and
has to respect the type of its (potential) output argument when writing
to it.</p>
<p>In order to avoid errors, values that have not the expected type will be
casted to the correct type, following the rules given in [@tab]:casting.
In this table, $\bot$ denotes a function that does nothing (the program
is an empty vector).</p>
<dl>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dt>| **Fro   | <strong>Int</strong> | **      | *       | <strong>Str</strong> | *       | <strong>Dur</strong> |</dt>
<dt>| m\To** |         | Float** | <em>Bool</em>* |         | <em>Func</em>* |         |</dt>
<dt>+=========+=========+=========+=========+=========+=========+=========+</dt>
<dt>| <strong>Int</strong> |         | Repre   | $       | D       | $\bot$  | A       |</dt>
<dt>|         |         | sented\ | 0 \righ | ecimal\ |         | bsolute |</dt>
<dt>|         |         | as      | tarrow  | represe |         | value   |</dt>
<dt>|         |         | float   | \text{f | ntation |         | as      |</dt>
<dt>|         |         |         | alse}$\ |         |         | milli   |</dt>
<dt>|         |         |         | $\ne    |         |         | seconds |</dt>
<dt>|         |         |         | q 0 \ri |         |         |         |</dt>
<dt>|         |         |         | ghtarro |         |         |         |</dt>
<dt>|         |         |         | w \text |         |         |         |</dt>
<dt>|         |         |         | {true}$ |         |         |         |</dt>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dt>| **      | R       |         | $       | D       | $\bot$  | A       |</dt>
<dt>| Float** | ounded\ |         | 0 \righ | ecimal\ |         | bsolute |</dt>
<dt>|         | to int  |         | tarrow  | represe |         | value   |</dt>
<dt>|         |         |         | \text{f | ntation |         | rounded |</dt>
<dt>|         |         |         | alse}$\ |         |         | to int  |</dt>
<dt>|         |         |         | $\ne    |         |         | as      |</dt>
<dt>|         |         |         | q 0 \ri |         |         | milli   |</dt>
<dt>|         |         |         | ghtarro |         |         | seconds |</dt>
<dt>|         |         |         | w \text |         |         |         |</dt>
<dt>|         |         |         | {true}$ |         |         |         |</dt>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dt>| *       | $       | $\t     |         | $\tex   | $\bot$  | ?       |</dt>
<dt>| <em>Bool</em>* | \text{f | ext{fal |         | t{false |         |         |</dt>
<dt>|         | alse} \ | se} \ri |         | } \righ |         |         |</dt>
<dt>|         | rightar | ghtarro |         | tarrow$ |         |         |</dt>
<dt>|         | row 0$\ | w 0.0$\ |         | &quot;       |         |         |</dt>
<dt>|         | $\text  | $       |         | False&quot;\ |         |         |</dt>
<dt>|         | {true}  | \text{t |         | $\te    |         |         |</dt>
<dt>|         | \righta | rue} \r |         | xt{true |         |         |</dt>
<dt>|         | rrow 1$ | ightarr |         | } \righ |         |         |</dt>
<dt>|         |         | ow 1.0$ |         | tarrow$ |         |         |</dt>
<dt>|         |         |         |         | &ldquo;True&rdquo;  |         |         |</dt>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dt>| <strong>Str</strong> | Parsed  | Parsed  | &quot;&quot;      |         | $\bot$  | Parsed  |</dt>
<dt>|         | as int\ | as      | $\righ  |         |         | as time |</dt>
<dt>|         | (0 if   | float\  | tarrow  |         |         | d       |</dt>
<dt>|         | error)  | (0 if   | \text{f |         |         | uration |</dt>
<dt>|         |         | error)  | alse}$\ |         |         | (0 if   |</dt>
<dt>|         |         |         | $       |         |         | error)  |</dt>
<dt>|         |         |         | \neq$&quot;&quot; |         |         |         |</dt>
<dt>|         |         |         | $\ri    |         |         |         |</dt>
<dt>|         |         |         | ghtarro |         |         |         |</dt>
<dt>|         |         |         | w \text |         |         |         |</dt>
<dt>|         |         |         | {true}$ |         |         |         |</dt>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dt>| *       | $\bot \ | $\      | $\bo    | Name of |         | ?       |</dt>
<dt>| <em>Func</em>* | rightar | bot \ri | t \righ | the\    |         |         |</dt>
<dt>|         | row 0$\ | ghtarro | tarrow  | f       |         |         |</dt>
<dt>|         | $\ne    | w 0.0$\ | \text{f | unction |         |         |</dt>
<dt>|         | q \bot  | $\neq   | alse}$\ |         |         |         |</dt>
<dt>|         | \righta | \bot \r | $\neq \ |         |         |         |</dt>
<dt>|         | rrow 1$ | ightarr | bot \ri |         |         |         |</dt>
<dt>|         |         | ow 1.0$ | ghtarro |         |         |         |</dt>
<dt>|         |         |         | w \text |         |         |         |</dt>
<dt>|         |         |         | {true}$ |         |         |         |</dt>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dt>| <strong>Dur</strong> | Milli   | Milli   | $0$ms   | Time as | $\bot$  |         |</dt>
<dt>|         | seconds | seconds | $\righ  | string  |         |         |</dt>
<dt>|         | as int  | repr    | tarrow  |         |         |         |</dt>
<dt>|         |         | esented | \text{f |         |         |         |</dt>
<dt>|         |         | as      | alse}$\ |         |         |         |</dt>
<dt>|         |         | float   | $\n     |         |         |         |</dt>
<dt>|         |         |         | eq 0$ms |         |         |         |</dt>
<dt>|         |         |         | $\ri    |         |         |         |</dt>
<dt>|         |         |         | ghtarro |         |         |         |</dt>
<dt>|         |         |         | w \text |         |         |         |</dt>
<dt>|         |         |         | {true}$ |         |         |         |</dt>
<dt>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+</dt>
<dd>
<p>Type casting rules.</p>
</dd>
</dl>
<p>[]{#tab:casting}</p>
<h2 id="sec:timing">
  Dealing with durations
  <a class="anchor" href="#sec:timing">#</a>
</h2>
<p>According to [@lst]:timespan (which is an extract of the file</p>
<pre><code>src/clock.rs
</code></pre>
<p>), variables representing durations can hold three kinds of values:
microseconds, beats, and steps. A duration expressed as microseconds is
an absolute time. A duration expressed as beats is a relative time: the
exact duration depends on the number of microseconds in a beat. A
duration expressed as steps is a relative time as well: the exact
duration depends on the number of beats in the step associated to the
BILL program in which the duration is used (that is, the step at which
the program execution started). The duration of a beat or a step can be
changed by BILL programs and by the environment.</p>
<figure>
<p><code>pub enum TimeSpan {
    Micros(u64),
    Beats(f64),
    Steps(f64),
}</code></p>
<figcaption><p>TimeSpan definition</p></figcaption>
</figure>
<p>[]{#lst:timespan}</p>
<p>Concrete durations are always expressed in microseconds. So, when a
time-stamp must be associated to an event or when a delay must be
applied the corresponding durations are converted to microseconds if
needed. Before that, durations are always kept as general as possible:
when an arithmetic operation is performed between two durations, the
most concrete one is converted to the kind of the most general, as show
in [@tab]:duration.</p>
<pre><code>                 **microseconds**   **beats**   **steps**
</code></pre>
<hr>
<p><strong>microseconds</strong>   microseconds       beats       steps
<strong>beats</strong>                             beats       steps
<strong>steps</strong>                                         steps</p>
<p>: Result kinds in arithmetic operations between durations</p>
<p>[]{#tab:duration}</p>
<p>Sometimes, one may want the result of a computation on durations not to
be as general as possible, e.g to be evaluated as microseconds
immediately, to prevent the duration to change with changes to the beat
duration or to a step duration. For that, we provide operations to
change the concreteness of a duration in [@sec]:control.</p>
<h2 id="sec:control">
  Control instructions
  <a class="anchor" href="#sec:control">#</a>
</h2>
<p>Control instructions allow to perform basic operations (boolean and
arithmetic) over variables. They also can change the control-flow of a
program.</p>
<p>Concretely, a BILL program is a vector of instructions. At any time, the
next instruction to be executed is given by a position in this vector
(think of the program counter for a processor) that the scheduler
stores. After executing an instruction, by default this position is
increased by one. To alter the control-flow, a few instructions allow to
arbitrarily change this position (jump instructions) or even to change
the vector that represents the current program (call and return
instructions).</p>
<p>The existing control instructions are given in [@lst]:asm, which is an
extract of the file</p>
<pre><code>src/lang/control_asm.rs
</code></pre>
<p>.</p>
<figure>
<p><code>pub enum ControlASM {
    // Arithmetic operations
    Add(Variable, Variable, Variable),
    Div(Variable, Variable, Variable),
    Mod(Variable, Variable, Variable),
    Mul(Variable, Variable, Variable),
    Sub(Variable, Variable, Variable),
    // Boolean operations
    And(Variable, Variable, Variable),
    Not(Variable, Variable),
    Or(Variable, Variable, Variable),
    Xor(Variable, Variable, Variable),
    // Bitwise operations
    BitAnd(Variable, Variable, Variable),
    BitNot(Variable, Variable),
    BitOr(Variable, Variable, Variable),
    BitXor(Variable, Variable, Variable),
    ShiftLeft(Variable, Variable, Variable),
    ShiftRightA(Variable, Variable, Variable),
    ShiftRightL(Variable, Variable, Variable),
    // String operations
    Concat(Variable, Variable, Variable),
    // Time manipulation
    AsBeats(Variable, Variable),
    AsMicros(Variable, Variable),
    AsSteps(Variable, Variable),
    // Memory manipulation
    DeclareGlobale(String, Variable),
    DeclareInstance(String, Variable),
    DeclareSequence(String, Variable),
    DeclareStep(String, Variable),
    Mov(Variable, Variable),
    // Jumps
    Jump(usize),
    JumpIf(Variable, usize),
    JumpIfDifferent(Variable, Variable, usize),
    JumpIfEqual(Variable, Variable, usize),
    JumpIfLess(Variable, Variable, usize),
    JumpIfLessOrEqual(Variable, Variable, usize),
    // Calls and returns
    CallFunction(Variable),
    CallProcedure(usize),
    Return,
  }</code></p>
<figcaption><p>Control instructions</p></figcaption>
</figure>
<p>[]{#lst:asm}</p>
<h3 id="arithmetic-operations">
  Arithmetic operations
  <a class="anchor" href="#arithmetic-operations">#</a>
</h3>
<p>These instructions are all of the form</p>
<pre><code>Op(x, y, z)
</code></pre>
<p>. Arguments x and y are inputs and z is an output. It is expected that x
and y are two numbers of the same type (Int, Float or Dur). If this is
not the case:</p>
<ul>
<li>
<p>if x is a number y will be casted to the type of x,</p>
</li>
<li>
<p>else if y is a number x will be casted to the type of y,</p>
</li>
<li>
<p>else they will both be casted to Int.</p>
</li>
</ul>
<p>The result of the operation will be casted to the type of z (if needed).</p>
<p>Each instruction performs a different operation, as shown in
[@tab]:arithmetic.</p>
<dl>
<dt>+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <strong>Op</strong> | <strong>Semantics</strong>               | <strong>Remark</strong>                  |</dt>
<dt>+========+=============================+=============================+</dt>
<dt>| Add    | $z \leftarrow x + y$        |                             |</dt>
<dt>+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Div    | $z \leftarrow x/y$          | $z \leftarrow 0$ if $y = 0$ |</dt>
<dt>+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Mod    | $z \left                    | $z \leftarrow x$ if         |</dt>
<dt>|        | arrow x\operatorname{mod}y$ | $y = 0$\                    |</dt>
<dt>|        |                             | $z \leftarrow 0$ if $y$ is  |</dt>
<dt>|        |                             | a float                     |</dt>
<dt>+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Mul    | $z \leftarrow x \times y$   |                             |</dt>
<dt>+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| Sub    | $z \leftarrow x - y$        |                             |</dt>
<dt>+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Arithmetic operations semantics</p>
</dd>
</dl>
<p>[]{#tab:arithmetic}</p>
<h3 id="boolean-operations">
  Boolean operations
  <a class="anchor" href="#boolean-operations">#</a>
</h3>
<p>These instructions are all of the form</p>
<pre><code>Op(x, y, z)
</code></pre>
<p>or</p>
<pre><code>Op(x, z)
</code></pre>
<p>. Arguments x and y are inputs and will be casted to bool (if needed).
Argument z is an output. The result of the operation will be casted to
the type of z (if needed).</p>
<p>Each instruction performs a different operation, as shown in
[@tab]:boolean.</p>
<p><strong>Op</strong>   <strong>Semantics</strong>               <strong>Remark</strong></p>
<hr>
<p>And      $z \leftarrow x \land y$ <br>
Not      $z \leftarrow \neg x$    <br>
Or       $z \leftarrow x \vee y$  <br>
Xor      $z \leftarrow x \oplus y$</p>
<p>: Boolean operations semantics</p>
<p>[]{#tab:boolean}</p>
<h3 id="bitwise-operations">
  Bitwise operations
  <a class="anchor" href="#bitwise-operations">#</a>
</h3>
<p>These instructions are all of the form</p>
<pre><code>Op(x, y, z)
</code></pre>
<p>or</p>
<pre><code>Op(x, z)
</code></pre>
<p>. Arguments x and y are inputs and will be casted to int (if needed).
Argument z is an output. The result of the operation will be casted to
the type of z (if needed).</p>
<p>Each instruction performs a different operation, as shown in
[@tab]:bitwise.</p>
<dl>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| <strong>Op</strong>      | <strong>Semantics</strong>           | <strong>Remark</strong>                  |</dt>
<dt>+=============+=========================+=============================+</dt>
<dt>| BitAnd      | $z \leftarrow x&amp; y$    |                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| BitNot      | $z \leftarrow \sim x$   |                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| BitOr       | $z \leftarrow x~|~y$    |                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| BitXor      | $z \leftarrow x\hat{}y$ |                             |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| ShiftLeft   | $z \leftarrow x \ll y$  | $z \leftarrow x$ if $y &lt; 0$ |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| ShiftRightA | $z \leftarrow x \gg y$  | arithmetic shift\           |</dt>
<dt>|             |                         | $z \leftarrow x$ if $y &lt; 0$ |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dt>| ShiftRightL | $z \leftarrow x \gg y$  | logical shift\              |</dt>
<dt>|             |                         | $z \leftarrow x$ if $y &lt; 0$ |</dt>
<dt>+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</dt>
<dd>
<p>Bitwise operations semantics (C-like syntax)</p>
</dd>
</dl>
<p>[]{#tab:bitwise}</p>
<h3 id="string-operations">
  String operations
  <a class="anchor" href="#string-operations">#</a>
</h3>
<p>These instructions are all of the form</p>
<pre><code>Op(x, y, z)
</code></pre>
<p>. Arguments x and y are inputs and will be casted to str (if needed).
Argument z is an output. The result of the operation will be casted to
the type of z (if needed).</p>
<p>Each instruction performs a different operation, as shown in
[@tab]:string.</p>
<p><strong>Op</strong>   <strong>Semantics</strong>        <strong>Remark</strong></p>
<hr>
<p>Concat   $z \leftarrow x.y$   string concatenation</p>
<p>: String operations semantics</p>
<p>[]{#tab:string}</p>
<h3 id="time-manipulation">
  Time manipulation
  <a class="anchor" href="#time-manipulation">#</a>
</h3>
<p>These instructions allow to perform conversions on durations.</p>
<p><strong>AsMicros(d, v).</strong> Casts $d$ to a duration. Set this duration to
microseconds, cast it to the type of $v$, and then store it in $v$.</p>
<p><strong>AsBeats(d, v).</strong> Casts $d$ to a duration. Set this duration to beats,
cast it to the type of $v$, and then store it in $v$.</p>
<p><strong>AsSteps(d, v).</strong> Casts $d$ to a duration. Set this duration to steps,
cast it to the type of $v$, and then store it in $v$.</p>
<h3 id="memory-manipulation">
  Memory manipulation
  <a class="anchor" href="#memory-manipulation">#</a>
</h3>
<p>The four variable declaration instructions (DeclareGlobal,
DeclareInstance, DeclareSequence, DeclareStep) are of the form</p>
<pre><code>Declare(name, value)
</code></pre>
<p>and will create a new (Global, Instance, Sequence or Step) variable
named</p>
<pre><code>name
</code></pre>
<p>and initialize its value to</p>
<pre><code>value
</code></pre>
<p>. The type of the new variable is the type of</p>
<pre><code>value
</code></pre>
<p>.</p>
<p>Notice that, in any program instruction arguments, if a variable that
does not exist is read this will give a 0 value. If a variable that does
not exist is written, the variable will be created. (except if it is an
environment variable, writing to environment variables has no effect).</p>
<p>The</p>
<pre><code>mov(x, z)
</code></pre>
<p>instruction semantics is $z \leftarrow x$. If needed, the value of</p>
<pre><code>x
</code></pre>
<p>will be casted to the type of</p>
<pre><code>z
</code></pre>
<p>.</p>
<h3 id="jumps">
  Jumps
  <a class="anchor" href="#jumps">#</a>
</h3>
<p>By default, the instructions of a BILL program are executed one after
the other in the order in which they are stored in the vector
representing the program. At each time, the position of the instruction
to be executed is stored by the scheduler (think of a program counter
for a processor). Assume that the place where this position is stored is
called</p>
<pre><code>pc
</code></pre>
<p>. By default, after executing an instruction, the scheduler increases</p>
<pre><code>pc
</code></pre>
<p>: $\text{pc } \leftarrow \text{ pc} + 1$. Jump instructions allow to
replace this standard update of</p>
<pre><code>pc
</code></pre>
<p>by something else, potentially based on a condition.</p>
<p>The semantics of the different jump instructions is given in
[@tab]:jumps. In each case, if the condition is $\text{true}$ then
$\text{pc } \leftarrow d\operatorname{mod}n$ (where $n$ is the number of
instructions in the program). Else,
$\text{pc } \leftarrow \text{ pc } + 1$.</p>
<p><strong>Instruction</strong>              <strong>Cond.</strong>       <strong>Remark</strong></p>
<hr>
<p>Jump(d)                      $\text{true}$<br>
JumpIf(x, d)                 $x$             $x$ casted to Bool
JumpIfDifferent(x, y, d)     $x \neq y$      $y$ casted to the type of $x$
JumpIfEqual(x, y, d)         $x = y$         $y$ casted to the type of $x$
JumpIfLess(x, y, d)          $x &lt; y$         $y$ casted to the type of $x$
JumpIfLessOrEqual(x, y, d)   $x \leq y$      $y$ casted to the type of $x$</p>
<p>: Jumps semantics</p>
<p>[]{#tab:jumps}</p>
<h3 id="calls-and-returns">
  Calls and returns
  <a class="anchor" href="#calls-and-returns">#</a>
</h3>
<p>TODO: pas mal de trucs à rajouter dans le scheduler pour gérer ça</p>
<p>A jump instruction always jumps to the same position in a program.
Hence, one cannot use them to simulate procedure calls (the return
position from a procedure depends on the point in code at which the jump
to the procedure happened).</p>
<p>Calls are jumps that store, in a stack, the position from which they
jumped. Returns are jumps that read in this stack to determine the
position to which they jump. This stack will be called <em>return stack</em>.</p>
<p><strong>CallFunction(f).</strong> Cast $f$ to a program, then replace the current
program $p$ with $f$. Push ($p,\text{ pc } + 1)$ into the return stack.
Set</p>
<pre><code>pc
</code></pre>
<p>to 0 (the start of the new program).</p>
<p><strong>CallProcedure(pos).</strong> Push $\left( p,\text{ pc } + 1 \right)$ (where
$p$ is the current program) into the return stack. Set</p>
<pre><code>pc
</code></pre>
<p>to pos.</p>
<p><strong>Return.</strong> Pop $\left( p,\text{ pos} \right)$ from the return stack.
Replace the current program with $p$ (if needed) and set</p>
<pre><code>pc
</code></pre>
<p>to pos. If the return stack is empty when using return, the program will
end.</p>
<h2 id="sec:effect">
  Effect instructions
  <a class="anchor" href="#sec:effect">#</a>
</h2>
<p>Effect instructions are constituted of an <em>Event</em> and a <em>TimeSpan</em>
([@lst]:instruction). The Event describes the effect of the instruction
on the World and the TimeSpan tells how much time shall elapse after the
event occurs.</p>
<p>The existing events are given in [@lst]:event, which is an extract of
the file</p>
<pre><code>src/lang/event.rs
</code></pre>
<p>.</p>
<p>In this section we give the semantics of these events.</p>
<figure>
<p><code>pub enum Event {
    // Meta
    Nop,
    List(Vec&lt;Event&gt;),
    // Music
    PlayChord(Vec&lt;Variable&gt;, Variable),
    // Time handling
    SetBeatDuration(Variable),
    SetCurrentStepDuration(Variable),
    SetStepDuration(Variable, Variable),
    // Program starting
    Continue,
    ContinueInstance(Variable),
    ContinueOldest(Variable),
    ContinueSequence(Variable),
    ContinueSequenceOldest(Variable),
    ContinueSequenceYoungest(Variable),
    ContinueStep(Variable),
    ContinueStepOldest(Variable, Variable),
    ContinueStepYoungest(Variable, Variable),
    ContinueYoungest(Variable),
    Start(Variable, Variable),
    // Program halting
    Pause,
    PauseInstance(Variable),
    PauseOldest(Variable),
    PauseSequence(Variable),
    PauseSequenceOldest(Variable, Variable),
    PauseSequenceYoungest(Variable, Variable),
    PauseStep(Variable),
    PauseStepOldest(Variable, Variable),
    PauseStepYoungest(Variable, Variable),
    PauseYoungest(Variable),
    Stop,
    StopInstance(Variable),
    StopOldest(Variable),
    StopSequence(Variable),
    StopSequenceOldest(Variable, Variable),
    StopSequenceYoungest(Variable, Variable),
    StopStep(Variable),
    StopStepOldest(Variable, Variable),
    StopStepYoungest(Variable, Variable),
    StopYoungest(Variable),
}</code></p>
<figcaption><p>Event definition</p></figcaption>
</figure>
<p>[]{#lst:event}</p>
<h3 id="meta-events">
  Meta events
  <a class="anchor" href="#meta-events">#</a>
</h3>
<p><strong>Nop.</strong> Does nothing.</p>
<p><strong>List(e).</strong> Performs all the events in $e$ as fast as possible (that
is, kind of simultaneously it there are not too much events in $e$), in
the order in which they are given.</p>
<h3 id="music-events">
  Music events
  <a class="anchor" href="#music-events">#</a>
</h3>
<p>Music events are the events that actually allow to play sound on a given
device. Not all devices accept all events.</p>
<p><strong>PlayChord(notes, d).</strong> Plays all the notes given in <em>notes</em> (casted to
int used as midi values) together for $d$ (casted to a duration and set
to milliseconds) milliseconds.</p>
<h3 id="time-handling-events">
  Time handling events
  <a class="anchor" href="#time-handling-events">#</a>
</h3>
<p>Time handling events allow to manage the relations between beats, step
duration, and absolute time.</p>
<p><strong>SetBeatDuration(t).</strong> Sets the duration of one beat to $t$ (casted to
a duration). This duration is set in milliseconds (absolute time) by
first evaluating $t$ in milliseconds. The standard use is to give $t$ in
milliseconds to setup a tempo. However, one could give $t$ in beats for
relative change of tempo (if $t$ is 3 beats the tempo is divided by 3 as
the duration of a beat is multiplied by 3).</p>
<p><strong>SetCurrentStepDuration(t).</strong> Sets the duration of the step associated
to the program instance calling this instruction to $t$ (casted to a
duration). This duration is set in beats if possible or, else, it is set
in milliseconds. The standard use is to give $t$ in beats, so that if
beat duration changes step duration changes accordingly. However one
could give $t$ in milliseconds to avoid this side effect.</p>
<p><strong>SetStepDuration(n, t).</strong> Same as SetCurrentStepDuration but for step
$n$ (casted to an int). See [@sec]:envvariables for knowing how to get
step numbers.</p>
<h3 id="sec:starting">
  Program starting events
  <a class="anchor" href="#sec:starting">#</a>
</h3>
<p>Starting events allow to initiate new program instances (<em>start</em>) and to
resume execution of program instances that were previously paused
(<em>continue</em>). How program instances can be paused is described in
[@sec]:halting.</p>
<p><strong>Continue.</strong> Resumes all currently paused program instances.</p>
<p><strong>ContinueInstance(n).</strong> Resumes the program instance with number $n$
(casted to an int). See [@sec]:envvariables for knowing how to get
instance numbers.</p>
<p><strong>ContinueOldest(k).</strong> Resumes the $k$ (casted to an int) program
instances that were paused the longest time ago.</p>
<p><strong>ContinueSequence(n).</strong> Resumes all currently paused program instances
corresponding to steps in sequence $n$ (casted to an int). See
[@sec]:envvariables for knowing how to get sequence numbers.</p>
<p><strong>ContinueSequenceOldest(n, k).</strong> Resumes the $k$ (casted to an int)
program instances corresponding to steps in sequence $n$ (casted to an
int) that were paused the longest time ago. See [@sec]:envvariables for
knowing how to get sequence numbers.</p>
<p><strong>ContinueSequenceYoungest(n, k).</strong> Resumes the $k$ (casted to an int)
program instances corresponding to steps in sequence $n$ (casted to an
int) that were paused the shortest time ago. See [@sec]:envvariables for
knowing how to get sequence numbers.</p>
<p><strong>ContinueStep(n).</strong> Resumes all currently paused program instances
corresponding to step $n$ (casted to an int). See [@sec]:envvariables
for knowing how to get step numbers.</p>
<p><strong>ContinueStepOldest(n, k).</strong> Resumes the $k$ (casted to an int) program
instances corresponding to step $n$ (casted to an int) that were paused
the longest time ago. See [@sec]:envvariables for knowing how to get
step numbers.</p>
<p><strong>ContinueStepYoungest(n, k).</strong> Resumes the $k$ (casted to an int)
program instances corresponding to step $n$ (casted to an int) that were
paused the shortest time ago. See [@sec]:envvariables for knowing how to
get step numbers.</p>
<p><strong>ContinueYoungest(k).</strong> Resumes the $k$ (casted to an int) program
instances that were paused the shortest time ago.</p>
<p><strong>Start(p, i).</strong> Starts a new instance of program $p$. If $p$ is a
function, then this function is used as a program. Else the program
corresponding to step $p$ (casted to an int) is used. The number of the
new instance is recorded in $i$ (after casting it to the type of $i$).
Remark that such a program instance is not associated to any step or
sequence. TODO: est-ce que ça ne devrait pas être associé au step depuis
lequel l&rsquo;instruction est appelée ? ou alors pouvoir donner un step en
paramètre ?</p>
<h3 id="sec:halting">
  Program halting events
  <a class="anchor" href="#sec:halting">#</a>
</h3>
<p>Halting events are of two kinds: <em>stop</em> events and <em>pause</em> events. Stop
events will end the execution of a (set of) program(s) instance(s).
Pause events will pause the execution of a (set of) program(s)
instance(s) allowing to continue their execution from the point at which
they where paused using program starting events ([@sec]:starting).</p>
<p>We describe here the stop events as the corresponding pause events have
the same behavior.</p>
<p><strong>Stop.</strong> Stops all the program instances currently running.</p>
<p><strong>StopInstance(n).</strong> Stops the program instance with number $n$ (casted
to an int). See [@sec]:envvariables for knowing how to get instance
numbers.</p>
<p><strong>StopOldest(k).</strong> Stops the $k$ (casted to an int) oldest program
instances (that started the longest time ago).</p>
<p><strong>StopSequence(n).</strong> Stops all the program instances corresponding to
steps in sequence number $n$ (casted to an int). See [@sec]:envvariables
for knowing how to get sequence numbers.</p>
<p><strong>StopSequenceOldest(n, k).</strong> Stops the $k$ (casted to an int) oldest
program instances (that started the longest time ago) corresponding to
steps in sequence number $n$ (casted to an int). See [@sec]:envvariables
for knowing how to get sequence numbers.</p>
<p><strong>StopSequenceYoungest(n, k).</strong> Stops the $k$ (casted to an int)
youngest program instances (that started the shortest time ago)
corresponding to steps in sequence number $n$ (casted to an int). See
[@sec]:envvariables for knowing how to get sequence numbers.</p>
<p><strong>StopStep(n).</strong> Stops all the program instances corresponding to step
number $n$ (casted to an int). See [@sec]:envvariables for knowing how
to get step numbers.</p>
<p><strong>StopStepOldest(n, k).</strong> Stops the $k$ (casted to an int) oldest
program instances (that started the longest time ago) corresponding to
step number $n$ (casted to an int). See [@sec]:envvariables for knowing
how to get step numbers.</p>
<p><strong>StopStepYoungest(n, k).</strong> Stops the $k$ (casted to an int) youngest
program instances (that started the shortest time ago) corresponding to
step number $n$ (casted to an int). See [@sec]:envvariables for knowing
how to get step numbers.</p>
<p><strong>StopYoungest(k).</strong> Stops the $k$ (casted to an int) youngest program
instances (that started the shortest time ago).</p>
<h2 id="sec:envvariables">
  Environment variables
  <a class="anchor" href="#sec:envvariables">#</a>
</h2>
<p>TODO: on aurait envie d&rsquo;avoir des variables d&rsquo;environnement qui sont des
ensembles, comment faire ? Ça demande sans doute d&rsquo;ajouter un type de
variable ? On voudrait aussi paramétrer les variables d&rsquo;environnement
mais en l&rsquo;état ce n&rsquo;est pas trop possible (par exemple pour obtenir le
nombre de pas dans la séquence n), la version actuelle ne fonctionne pas
vraiment car on ne peut pas construire les noms de variable dans un
programme BILL. Il faut peut-être que les variables en question soient
remplacées par des évènements (getters)</p>
<p>TODO: à ajouter dans l&rsquo;outil (mais pas tout de suite, il faut d&rsquo;abord
voir comment ça devrait marcher exactement)</p>
<p>The environment variables provided by BuboCore are given below. Some of
them are parameterized for simplicity. Parameters are depicted here
between dollars signs, they should be replaced by integers. For example,
Sequence$n$NumSteps corresponds to the variables Sequence1NumSteps,
Sequence2NumSteps, and so on.</p>
<ul>
<li>
<p><strong>InstanceID.</strong> ID of this program instance.</p>
</li>
<li>
<p><strong>Instance$n$SequenceID.</strong> ID of the sequence containing the step
associated to the program instance number $n$ (or the instance of the
program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$SequenceBeats.</strong> Number of beats in the sequence
containing the step associated to the program instance number $n$ (or
the instance of the program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$SequenceMicros.</strong> Number of microseconds in the
sequence containing the step associated to the program instance number
$n$ (or the instance of the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>Instance$n$StepID.</strong> ID of the step associated to the program
instance number $n$ (or the instance of the program using this
variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$StepBeats.</strong> Number of beats in the step associated to
the program instance number $n$ (or the instance of the program using
this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$StepMicros.</strong> Number of microseconds in the step
associated to the program instance number $n$ (or the instance of the
program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$SequenceNumInstances.</strong> Same as NumInstances but only
for instances corresponding to the sequence containing the step
associated to the program instance number $n$ (or the instance of the
program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$SequenceNumRunning.</strong> Same as NumRunning but only for
instances corresponding to the sequence containing the step associated
to the program instance number $n$ (or the instance of the program
using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$SequenceNumPaused.</strong> Same as NumPaused but only for
instances corresponding to the sequence containing the step associated
to the program instance number $n$ (or the instance of the program
using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Instance$n$StepNumInstances.</strong> Same as NumInstances but only for
instances corresponding to the step associated to the program instance
number $n$ (or the instance of the program using this variable if $n$
is omitted).</p>
</li>
<li>
<p><strong>Instance$n$StepNumRunning.</strong> Same as NumRunning but only for
instances corresponding to the step associated to the program instance
number $n$ (or the instance of the program using this variable if $n$
is omitted).</p>
</li>
<li>
<p><strong>Instance$n$StepNumPaused.</strong> Same as NumPaused but only for
instances corresponding to the step associated to the program instance
number $n$ (or the instance of the program using this variable if $n$
is omitted).</p>
</li>
<li>
<p><strong>NumInstances.</strong> Number of instances currently running or paused.</p>
</li>
<li>
<p><strong>NumPaused.</strong> Number of instances currently paused.</p>
</li>
<li>
<p><strong>NumRunning.</strong> Number of instances currently running.</p>
</li>
<li>
<p><strong>NumSequences.</strong> Number of sequences.</p>
</li>
<li>
<p><strong>Sequence$n$NumSteps.</strong> Number of steps in sequence number $n$.</p>
</li>
<li>
<p><strong>SequenceID.</strong> ID of the sequence containing the step corresponding
to this program.</p>
</li>
<li>
<p><strong>Sequence$n$Beats.</strong> Number of beats in the sequence number $n$ (or
the sequence containing the step associated to the program using this
variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Sequence$n$Micros.</strong> Number of microseconds in the sequence number
$n$ (or the sequence containing the step associated to the program
using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Sequence$n$NumInstances.</strong> Same as NumInstances but only for
instances corresponding to the sequence number $n$ (or the sequence
containing the step associated to the program using this variable if
$n$ is omitted).</p>
</li>
<li>
<p><strong>Sequence$n$NumRunning.</strong> Same as NumRunning but only for instances
corresponding to the sequence number $n$ (or the sequence containing
the step associated to the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>Sequence$n$NumPaused.</strong> Same as NumPaused but only for instances
corresponding to the sequence number $n$ (or the sequence containing
the step associated to the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>StepID.</strong> ID of the step corresponding to this program.</p>
</li>
<li>
<p><strong>Step$n$SequenceID.</strong> ID of the sequence containing the step number
$n$ (or the step associated to the program using this variable if $n$
is omitted).</p>
</li>
<li>
<p><strong>Step$n$SequenceBeats.</strong> Number of beats in the sequence containing
the step number $n$ (or the step associated to the program using this
variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Step$n$SequenceMicros.</strong> Number of microseconds in the sequence
containing the step number $n$ (or the step associated to the program
using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Step$n$Beats.</strong> Number of beats in the step number $n$ (or the
step associated to the program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Step$n$Micros.</strong> Number of microseconds in the step number $n$ (or
the step associated to the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>Step$n$NumInstances.</strong> Same as NumInstances but only for instances
corresponding to the step number $n$ (or the step associated to the
program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Step$n$NumRunning.</strong> Same as NumRunning but only for instances
corresponding to the step number $n$ (or the step associated to the
program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Step$n$NumPaused.</strong> Same as NumPaused but only for instances
corresponding to the step number $n$ (or the step associated to the
program using this variable if $n$ is omitted).</p>
</li>
<li>
<p><strong>Step$n$SequenceNumInstances.</strong> Same as NumInstances but only for
instances corresponding to the sequence containing the step number $n$
(or the step associated to the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>Step$n$SequenceNumRunning.</strong> Same as NumRunning but only for
instances corresponding to the sequence containing the step number $n$
(or the step associated to the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>Step$n$SequenceNumPaused.</strong> Same as NumPaused but only for
instances corresponding to the sequence containing the step number $n$
(or the step associated to the program using this variable if $n$ is
omitted).</p>
</li>
<li>
<p><strong>TotalBeats.</strong> Number of beats since the launch of BuboCore.</p>
</li>
<li>
<p><strong>TotalMicros.</strong> Number of microseconds since the launch of BuboCore.
This cannot be computed from TotalBeats as the duration of a beat may
have changed over time.</p>
</li>
<li>
<p><strong>BeatMicros.</strong> Number of microseconds in a beat.</p>
</li>
</ul>
<h1 id="guidelines-for-building-a-custom-scripting-language">
  Guidelines for building a custom scripting language
  <a class="anchor" href="#guidelines-for-building-a-custom-scripting-language">#</a>
</h1>
<p>In order to build a custom scripting language one needs to be able to
compile it to BILL. There are two possibilities for writing a compiler
compatible with BuboCore:</p>
<ul>
<li>
<p>compilers written in RUST can be integrated as modules of BuboCore,
and</p>
</li>
<li>
<p>compilers built with any technology can be provided as binaries that
BuboCore will call.</p>
</li>
</ul>
<p>The first method is preferred as it allows to directly build BILL
programs as RUST data-structures and ensures a better integration into
BuboCore. It also allows to easily distribute new scripting languages: a
simple pull request on our Github repository<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> will let us integrate
any scripting language into the next versions of BuboCore.</p>
<h2 id="compiler-integration-into-bubocore">
  Compiler integration into BuboCore
  <a class="anchor" href="#compiler-integration-into-bubocore">#</a>
</h2>
<p>Building a custom scripting langage requires to know how to build
BuboCore, please refer to the appropriate document<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> for that part.</p>
<p>In order to add a compiler for a new script language one has to comply
with the following guidelines:</p>
<ul>
<li>
<p>create a directory with the name of the language in</p>
<pre><code>src/compiler/
</code></pre>
<p>and implement the</p>
<pre><code>compiler
</code></pre>
<p>trait by providing a</p>
<pre><code>compile
</code></pre>
<p>function that given a script in the language (provided as a string)
produces the corresponding BILL code,</p>
</li>
<li>
<p>create a</p>
<pre><code>.rs
</code></pre>
<p>file with the name of the language in</p>
<pre><code>src/compiler/
</code></pre>
<p>and export (</p>
<pre><code>pub use
</code></pre>
<p>) the</p>
<pre><code>compiler
</code></pre>
<p>implementation,</p>
</li>
<li>
<p>declare the new module (</p>
<pre><code>pub mod
</code></pre>
<p>) in the</p>
<pre><code>src/compiler.rs
</code></pre>
<p>file.</p>
</li>
</ul>
<p>As an example, one can have a look at the <em>dummylang</em> language that has
been created for testing purposes while developing BuboCore:</p>
<ul>
<li>
<p>the compiler trait is implemented in</p>
<pre><code>src/compiler/dummylang/dummycompiler.rs
</code></pre>
<p>,</p>
</li>
<li>
<p>it is exported in</p>
<pre><code>src/compiler/dummylang/dummylang.rs
</code></pre>
<p>by the line</p>
<pre><code>pub use dummycompiler::DummyCompiler;
</code></pre>
<p>,</p>
</li>
<li>
<p>it is declared in</p>
<pre><code>src/compiler.rs
</code></pre>
<p>by the line</p>
<pre><code>pub mod dummylang;
</code></pre>
<p>.</p>
</li>
</ul>
<h2 id="compiler-as-a-standalone-binary">
  Compiler as a standalone binary
  <a class="anchor" href="#compiler-as-a-standalone-binary">#</a>
</h2>
<p>TODO: regarder comment ça marche et faire un exemple</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/Bubobubobubobubo/deep-bubocore">https://github.com/Bubobubobubobubo/deep-bubocore</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>TODO (quand la doc pour construire BuboCore sera écrite il faudra
la référencer ici)&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#general-overview">General overview</a></li>
    <li><a href="#lifespan-of-a-bill-program-execution">Lifespan of a BILL program execution</a></li>
    <li><a href="#how-bill-programs-are-executed">How BILL programs are executed</a>
      <ul>
        <li><a href="#sec:execsingle">Execution of a single program</a></li>
        <li><a href="#execution-of-several-programs-in-parallel">Execution of several programs in parallel</a></li>
      </ul>
    </li>
    <li><a href="#pattern-sequences-steps-and-some-vocabulary">Pattern, sequences, steps and some vocabulary</a></li>
    <li><a href="#how-variables-are-handled">How variables are handled</a>
      <ul>
        <li><a href="#environment-variables">Environment variables</a></li>
        <li><a href="#global-variables">Global variables</a></li>
        <li><a href="#sequence-variables">Sequence variables</a></li>
        <li><a href="#step-variables">Step variables</a></li>
        <li><a href="#instance-variables">Instance variables</a></li>
        <li><a href="#variables-with-similar-names">Variables with similar names</a></li>
      </ul>
    </li>
    <li><a href="#a-few-words-on-functions">A few words on functions</a></li>
  </ul>

  <ul>
    <li><a href="#sec:variables">Types of variables</a>
      <ul>
        <li><a href="#existing-types">Existing types</a></li>
        <li><a href="#type-casting">Type casting</a></li>
      </ul>
    </li>
    <li><a href="#sec:timing">Dealing with durations</a></li>
    <li><a href="#sec:control">Control instructions</a>
      <ul>
        <li><a href="#arithmetic-operations">Arithmetic operations</a></li>
        <li><a href="#boolean-operations">Boolean operations</a></li>
        <li><a href="#bitwise-operations">Bitwise operations</a></li>
        <li><a href="#string-operations">String operations</a></li>
        <li><a href="#time-manipulation">Time manipulation</a></li>
        <li><a href="#memory-manipulation">Memory manipulation</a></li>
        <li><a href="#jumps">Jumps</a></li>
        <li><a href="#calls-and-returns">Calls and returns</a></li>
      </ul>
    </li>
    <li><a href="#sec:effect">Effect instructions</a>
      <ul>
        <li><a href="#meta-events">Meta events</a></li>
        <li><a href="#music-events">Music events</a></li>
        <li><a href="#time-handling-events">Time handling events</a></li>
        <li><a href="#sec:starting">Program starting events</a></li>
        <li><a href="#sec:halting">Program halting events</a></li>
      </ul>
    </li>
    <li><a href="#sec:envvariables">Environment variables</a></li>
  </ul>

  <ul>
    <li><a href="#compiler-integration-into-bubocore">Compiler integration into BuboCore</a></li>
    <li><a href="#compiler-as-a-standalone-binary">Compiler as a standalone binary</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












